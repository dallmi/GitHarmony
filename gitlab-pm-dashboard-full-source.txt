# GitLab PM Dashboard - Complete Source Code for Claude AI

Generated: Sat Nov 22 13:54:30 CET 2025

---


## FILE: src/App.jsx

```javascript
import React, { useState, useEffect } from 'react'
import { isConfigured, loadConfig, getActiveProjectId } from './services/storageService'
import useGitLabData from './hooks/useGitLabData'
import useHealthScore from './hooks/useHealthScore'
import useRisks from './hooks/useRisks'
import { IterationFilterProvider } from './contexts/IterationFilterContext'
import Header from './components/Header'
import Tabs from './components/Tabs'
import GroupedTabs from './components/GroupedTabs'
import RoleSelectorModal from './components/RoleSelectorModal'
import IterationFilterDropdown from './components/IterationFilterDropdown'
import { getViewPreference } from './services/userPreferencesService'
import PortfolioFilterDropdown from './components/PortfolioFilterDropdown'
import ConfigModal from './components/ConfigModal'
import ExecutiveDashboard from './components/ExecutiveDashboard'
import EnhancedExecutiveDashboard from './components/EnhancedExecutiveDashboard'
import RoadmapView from './components/RoadmapView'
import VelocityView from './components/VelocityView'
import StakeholderHubView from './components/StakeholderHubView'
import IssueComplianceView from './components/IssueComplianceView'
import CycleTimeView from './components/CycleTimeView'
import BackupRestoreView from './components/BackupRestoreView'
// Consolidated views
import EpicManagementView from './components/EpicManagementView'
import RiskManagementView from './components/RiskManagementView'
import SprintManagementView from './components/SprintManagementView'
import CrossTeamCoordinationView from './components/CrossTeamCoordinationView'
import ResourcePlanningView from './components/ResourcePlanningView'
import TeamManagementView from './components/TeamManagementView'
import ReleasePlanningView from './components/ReleasePlanningView'
import DebugPanel from './components/DebugPanel'

function App() {
  console.log('App: Component initializing...')

  const [activeView, setActiveView] = useState('executive')
  console.log('App: activeView state initialized:', activeView)

  // Log whenever activeView changes
  useEffect(() => {
    console.log('üîÑ ACTIVE VIEW CHANGED TO:', activeView)
    console.log('Timestamp:', new Date().toISOString())
  }, [activeView])

  // Wrapper for setActiveView with detailed logging
  const handleViewChange = (newView) => {
    console.log('=== VIEW CHANGE REQUESTED ===')
    console.log('Current view:', activeView)
    console.log('New view:', newView)
    console.log('Type of newView:', typeof newView)
    try {
      setActiveView(newView)
      console.log('‚úÖ setActiveView called successfully')
    } catch (err) {
      console.error('‚ùå Error calling setActiveView:', err)
    }
  }

  const configured = isConfigured()
  console.log('App: Configuration check:', configured)

  const [showConfigModal, setShowConfigModal] = useState(!configured)
  const [showRoleModal, setShowRoleModal] = useState(false)
  const [showDebugPanel, setShowDebugPanel] = useState(false)
  const [useGroupedNav, setUseGroupedNav] = useState(getViewPreference() === 'grouped')
  console.log('App: showConfigModal:', !configured)

  console.log('App: Calling useGitLabData hook...')
  const { issues, milestones, epics, crossProjectData, loading, error, refresh } = useGitLabData()
  console.log('App: GitLab data:', { issuesCount: issues?.length, milestonesCount: milestones?.length, epicsCount: epics?.length, loading, error })
  if (crossProjectData) {
    console.log('App: Cross-project data available:', crossProjectData.statistics)
  }

  console.log('App: Calling useHealthScore hook...')
  const { stats, healthScore } = useHealthScore(issues, milestones)
  console.log('App: Health data:', { stats, healthScore })

  console.log('App: Calling useRisks hook...')
  const { risks } = useRisks()
  console.log('App: Risks data:', { risksCount: risks?.length })

  const handleConfigSave = () => {
    console.log('App: handleConfigSave called')
    setShowConfigModal(false)
    refresh()
  }

  const handleProjectSwitch = (projectId) => {
    console.log('App: handleProjectSwitch called with:', projectId)
    // Refresh data after switching project
    refresh()
    // Switch to executive view
    handleViewChange('executive')
  }

  console.log('App: About to render, current state:', { activeView, showConfigModal, configured, issuesCount: issues?.length, loading })

  return (
    <IterationFilterProvider issues={issues}>
      <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
        <Header
          stats={stats}
          healthScore={healthScore}
          onRefresh={refresh}
          onConfigure={() => setShowConfigModal(true)}
          onChangeRole={() => setShowRoleModal(true)}
          onDebug={() => setShowDebugPanel(true)}
          loading={loading}
        />

        {useGroupedNav ? (
          <GroupedTabs
            activeView={activeView}
            onViewChange={handleViewChange}
            onProjectChange={isConfigured() ? (projectId) => {
              if (projectId === 'cross-project') {
                // Cross-project mode: trigger data refresh to aggregate all projects
                console.log('Cross-project view activated - refreshing data')
                refresh()
              } else {
                // Project switched, data will reload
                handleProjectSwitch(projectId)
              }
            } : null}
          />
        ) : (
          <Tabs activeView={activeView} onViewChange={handleViewChange} />
        )}

        {/* Iteration Filter - Shows on views that benefit from iteration filtering */}
        {/* Positioned consistently in top-right across all views */}
        {isConfigured() && issues.length > 0 && (
          [
            'executive',
            'compliance',
            'cycletime',
            'resources',
            'resourceplanning',
            'teammanagement',
            'velocity',
            'sprintmanagement',
            'epicmanagement',
            'riskmanagement',
            'roadmap',
            'stakeholders',
            'crossteam',
            'releases'
            // Note: 'backup' view doesn't need iteration filter
          ].includes(activeView)
        ) && (
          <div style={{
            position: 'sticky',
            top: '0',
            zIndex: 800,
            background: 'white',
            padding: '12px 20px',
            borderBottom: '1px solid #E5E7EB',
            display: 'flex',
            justifyContent: 'flex-end'
          }}>
            <IterationFilterDropdown />
          </div>
        )}

        <div style={{ flex: 1, paddingTop: '20px' }}>
        {error && (
          <div className="container">
            <div className="card" style={{ background: '#FEE2E2', borderColor: '#DC2626', color: '#DC2626' }}>
              <strong>Error:</strong> {error}
            </div>
          </div>
        )}

        {loading && !issues.length && (
          <div className="container">
            <div className="card text-center">
              <p>Loading GitLab data...</p>
            </div>
          </div>
        )}

        {!loading && !error && !issues.length && isConfigured() && (
          <div className="container">
            <div className="card text-center">
              <p>No issues found. Please check your configuration.</p>
            </div>
          </div>
        )}

        {!isConfigured() && !showConfigModal && (
          <div className="container">
            <div className="card text-center">
              <h2 className="mb-2">Welcome to GitLab Project Management</h2>
              <p className="mb-2">Please configure your GitLab connection to get started.</p>
              <button className="btn btn-primary" onClick={() => setShowConfigModal(true)}>
                Configure Now
              </button>
            </div>
          </div>
        )}

        {/* Backup view is always accessible, even without configuration */}
        {activeView === 'backup' && <BackupRestoreView />}

        {isConfigured() && issues.length > 0 && (
          <>
            {activeView === 'executive' && (
              <EnhancedExecutiveDashboard
                stats={stats}
                healthScore={healthScore}
                issues={issues}
                milestones={milestones}
                epics={epics}
                risks={risks}
              />
            )}
            {activeView === 'compliance' && <IssueComplianceView issues={issues} />}
            {activeView === 'cycletime' && <CycleTimeView issues={issues} />}
            {activeView === 'epicmanagement' && <EpicManagementView epics={epics} issues={issues} crossProjectData={crossProjectData} />}
            {activeView === 'riskmanagement' && <RiskManagementView epics={epics} issues={issues} />}
            {activeView === 'roadmap' && <RoadmapView issues={issues} milestones={milestones} />}
            {activeView === 'sprintmanagement' && <SprintManagementView issues={issues} onNavigate={handleViewChange} />}
            {activeView === 'velocity' && <VelocityView issues={issues} />}
            {activeView === 'resourceplanning' && <ResourcePlanningView issues={issues} milestones={milestones} />}
            {activeView === 'teammanagement' && <TeamManagementView issues={issues} milestones={milestones} crossProjectMode={getActiveProjectId() === 'cross-project'} />}
            {activeView === 'stakeholders' && <StakeholderHubView stats={stats} healthScore={healthScore} />}
            {activeView === 'crossteam' && <CrossTeamCoordinationView issues={issues} epics={epics} milestones={milestones} />}
            {activeView === 'releases' && <ReleasePlanningView issues={issues} milestones={milestones} epics={epics} />}
          </>
        )}
      </div>

      <ConfigModal
        show={showConfigModal}
        onClose={() => setShowConfigModal(false)}
        onSave={handleConfigSave}
        onProjectSwitch={handleProjectSwitch}
      />

      <RoleSelectorModal
        show={showRoleModal}
        onClose={() => setShowRoleModal(false)}
      />

      {/* Debug Panel - Press Ctrl+Alt+D to toggle */}
      <DebugPanel
        externalVisible={showDebugPanel}
        onToggle={setShowDebugPanel}
      />
      </div>
    </IterationFilterProvider>
  )
}

export default App

```

---


## FILE: src/main.jsx

```javascript
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './styles/main.css'
import App from './App.jsx'
import ErrorBoundary from './components/ErrorBoundary'

console.log('=== GitLab PM Dashboard - Starting ===')
console.log('Environment:', {
  protocol: window.location.protocol,
  pathname: window.location.pathname,
  userAgent: navigator.userAgent,
  reactVersion: StrictMode ? 'React 18+' : 'Unknown'
})

try {
  console.log('Step 1: Looking for root element...')
  const rootElement = document.getElementById('root')

  if (!rootElement) {
    console.error('ERROR: Root element not found!')
    document.body.innerHTML = '<div style="padding: 40px; font-family: sans-serif;"><h1>Error: Root element missing</h1><p>Cannot find element with id="root"</p></div>'
    throw new Error('Root element not found')
  }

  console.log('Step 2: Root element found:', rootElement)
  console.log('Step 3: Creating React root...')

  const root = createRoot(rootElement)
  console.log('Step 4: React root created successfully')

  console.log('Step 5: Rendering App component with ErrorBoundary...')
  root.render(
    <StrictMode>
      <ErrorBoundary>
        <App />
      </ErrorBoundary>
    </StrictMode>
  )

  console.log('‚úÖ App rendered successfully!')

} catch (error) {
  console.error('‚ùå FATAL ERROR during initialization:', error)
  console.error('Error stack:', error.stack)

  // Show error on page
  document.body.innerHTML = `
    <div style="padding: 40px; font-family: sans-serif; max-width: 800px; margin: 0 auto;">
      <h1 style="color: #DC2626;">GitLab PM Dashboard - Initialization Error</h1>
      <h2>Error Details:</h2>
      <pre style="background: #FEE2E2; padding: 16px; border-radius: 8px; overflow-x: auto;">${error.message}\n\n${error.stack}</pre>
      <h2>Debug Information:</h2>
      <pre style="background: #F3F4F6; padding: 16px; border-radius: 8px; overflow-x: auto;">${JSON.stringify({
        protocol: window.location.protocol,
        pathname: window.location.pathname,
        userAgent: navigator.userAgent
      }, null, 2)}</pre>
      <p>Please check the browser console (F12) for more details and share this with the developer.</p>
    </div>
  `
}

```

---


## FILE: src/components/ConfigModal.jsx

```javascript
import React, { useState } from 'react'
import {
  loadConfig, saveConfig,
  getAllProjects, saveProject, removeProject, setActiveProject,
  getAllGroups, saveGroup, removeGroup, setActiveGroup
} from '../services/storageService'
import ProjectGroupManager from './ProjectGroupManager'

export default function ConfigModal({ show, onClose, onSave, onProjectSwitch }) {
  const existingConfig = loadConfig()
  const [activeTab, setActiveTab] = useState('connection')

  const [mode, setMode] = useState(existingConfig.mode || 'project')
  const [gitlabUrl, setGitlabUrl] = useState(existingConfig.gitlabUrl || 'https://gitlab.com')
  const [projectId, setProjectId] = useState(existingConfig.projectId || '')
  const [groupPaths, setGroupPaths] = useState(
    existingConfig.groupPaths && Array.isArray(existingConfig.groupPaths)
      ? existingConfig.groupPaths
      : (existingConfig.groupPath ? [existingConfig.groupPath] : [''])
  )
  // Single centralized token for all operations
  const [token, setToken] = useState(existingConfig.token || '')
  const [filter2025, setFilter2025] = useState(existingConfig.filter2025 || false)

  // Portfolio management state
  const [projects, setProjects] = useState(getAllProjects())
  const [showAddForm, setShowAddForm] = useState(false)
  const [editingProject, setEditingProject] = useState(null)
  const [formData, setFormData] = useState({
    name: '',
    gitlabUrl: 'https://gitlab.com',
    projectId: '',
    groupPaths: ['']
  })

  // Group/Pod management state
  const [groups, setGroups] = useState(getAllGroups())
  const [showAddGroupForm, setShowAddGroupForm] = useState(false)
  const [editingGroup, setEditingGroup] = useState(null)
  const [groupFormData, setGroupFormData] = useState({
    name: '',
    gitlabUrl: 'https://gitlab.com',
    groupPath: ''
  })

  if (!show) return null

  const handleSave = () => {
    // Filter out empty group paths and save both formats for compatibility
    const filteredGroupPaths = groupPaths.filter(path => path.trim() !== '')
    const config = {
      gitlabUrl,
      projectId,
      groupPath: filteredGroupPaths[0] || '', // For backward compatibility
      groupPaths: filteredGroupPaths, // New format supporting multiple paths
      token,
      mode,
      filter2025
    }

    saveConfig(config)
    onSave()
    onClose()
  }

  const handleAddGroupPath = () => {
    setGroupPaths([...groupPaths, ''])
  }

  const handleUpdateGroupPath = (index, value) => {
    const updated = [...groupPaths]
    updated[index] = value
    setGroupPaths(updated)
  }

  const handleRemoveGroupPath = (index) => {
    if (groupPaths.length > 1) {
      setGroupPaths(groupPaths.filter((_, i) => i !== index))
    }
  }

  const handleAddFormGroupPath = () => {
    setFormData({ ...formData, groupPaths: [...formData.groupPaths, ''] })
  }

  const handleUpdateFormGroupPath = (index, value) => {
    const updated = [...formData.groupPaths]
    updated[index] = value
    setFormData({ ...formData, groupPaths: updated })
  }

  const handleRemoveFormGroupPath = (index) => {
    if (formData.groupPaths.length > 1) {
      setFormData({ ...formData, groupPaths: formData.groupPaths.filter((_, i) => i !== index) })
    }
  }

  // Portfolio management functions
  const handleAddProject = () => {
    if (!formData.name || !formData.projectId) {
      alert('Please fill in all required fields')
      return
    }

    const filteredGroupPaths = formData.groupPaths.filter(path => path.trim() !== '')
    const projectData = {
      ...formData,
      groupPath: filteredGroupPaths[0] || '', // For backward compatibility
      groupPaths: filteredGroupPaths
    }

    const updatedProjects = saveProject(projectData)
    setProjects(updatedProjects)
    setFormData({
      name: '',
      gitlabUrl: 'https://gitlab.com',
      token: '',
      projectId: '',
      groupPaths: ['']
    })
    setShowAddForm(false)
    setEditingProject(null)
  }

  const handleEditProject = (project) => {
    setEditingProject(project.id)
    setFormData({
      id: project.id,
      name: project.name,
      gitlabUrl: project.gitlabUrl,
      projectId: project.projectId,
      groupPaths: project.groupPaths && Array.isArray(project.groupPaths) && project.groupPaths.length > 0
        ? project.groupPaths
        : (project.groupPath ? [project.groupPath] : [''])
    })
    setShowAddForm(true)
  }

  const handleCancelEdit = () => {
    setShowAddForm(false)
    setEditingProject(null)
    setFormData({
      name: '',
      gitlabUrl: 'https://gitlab.com',
      projectId: '',
      groupPaths: ['']
    })
  }

  const handleRemoveProject = (projectId) => {
    if (!confirm('Are you sure you want to remove this project?')) {
      return
    }

    const updatedProjects = removeProject(projectId)
    setProjects(updatedProjects)
  }

  const handleSwitchProject = (projectId) => {
    setActiveProject(projectId)
    if (onProjectSwitch) {
      onProjectSwitch(projectId)
    }
    onClose()
  }

  // Group/Pod management functions
  const handleAddGroup = () => {
    if (!groupFormData.name || !groupFormData.groupPath) {
      alert('Please fill in all required fields (Name and Group Path/ID)')
      return
    }

    const updatedGroups = saveGroup(groupFormData)
    setGroups(updatedGroups)
    setGroupFormData({
      name: '',
      gitlabUrl: 'https://gitlab.com',
      groupPath: ''
    })
    setShowAddGroupForm(false)
    setEditingGroup(null)
  }

  const handleEditGroup = (group) => {
    setEditingGroup(group.id)
    setGroupFormData({
      id: group.id,
      name: group.name,
      gitlabUrl: group.gitlabUrl,
      groupPath: group.groupPath
    })
    setShowAddGroupForm(true)
  }

  const handleCancelGroupEdit = () => {
    setShowAddGroupForm(false)
    setEditingGroup(null)
    setGroupFormData({
      name: '',
      gitlabUrl: 'https://gitlab.com',
      groupPath: ''
    })
  }

  const handleRemoveGroup = (groupId) => {
    if (!confirm('Are you sure you want to remove this group/pod?')) {
      return
    }

    const updatedGroups = removeGroup(groupId)
    setGroups(updatedGroups)
  }

  const handleSwitchGroup = (groupId) => {
    setActiveGroup(groupId)
    if (onProjectSwitch) {
      onProjectSwitch(`pod:${groupId}`)
    }
    onClose()
  }

  return (
    <div
      className="modal-overlay"
      onMouseDown={(e) => {
        // Only close if clicking directly on the overlay, not when releasing from text selection
        if (e.target === e.currentTarget) {
          onClose()
        }
      }}
    >
      <div className="modal" onClick={e => e.stopPropagation()} style={{ maxWidth: '800px' }}>
        <div className="modal-header">
          <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
            <h2>Configuration</h2>
          </div>
          <button
            className="btn"
            onClick={onClose}
            style={{ padding: '4px 8px' }}
          >
            √ó
          </button>
        </div>

        {/* Tabs */}
        <div className="tabs" style={{ borderBottom: '1px solid var(--border-light)', margin: 0 }}>
          <button
            className={`tab ${activeTab === 'connection' ? 'active' : ''}`}
            onClick={() => setActiveTab('connection')}
          >
            Connection
          </button>
          <button
            className={`tab ${activeTab === 'projects' ? 'active' : ''}`}
            onClick={() => setActiveTab('projects')}
          >
            Projects
          </button>
          <button
            className={`tab ${activeTab === 'groups' ? 'active' : ''}`}
            onClick={() => setActiveTab('groups')}
          >
            Project Groups
          </button>
          <button
            className={`tab ${activeTab === 'pods' ? 'active' : ''}`}
            onClick={() => setActiveTab('pods')}
          >
            Pods
          </button>
        </div>

        <div className="modal-body">
          {activeTab === 'connection' && (
            <>
              <div className="form-group">
                <label className="form-label">GitLab URL</label>
                <input
                  type="text"
                  className="form-input"
                  value={gitlabUrl}
                  onChange={e => setGitlabUrl(e.target.value)}
                  placeholder="https://gitlab.com"
                />
              </div>

              <div className="form-group">
                <label className="form-label">Mode</label>
                <div style={{ display: 'flex', gap: '12px', marginTop: '8px' }}>
                  <label style={{ display: 'flex', alignItems: 'center', gap: '8px', padding: '12px', border: `2px solid ${mode === 'project' ? '#3B82F6' : '#E5E7EB'}`, borderRadius: '8px', cursor: 'pointer', flex: 1, background: mode === 'project' ? '#EFF6FF' : 'white' }}>
                    <input
                      type="radio"
                      name="mode"
                      value="project"
                      checked={mode === 'project'}
                      onChange={e => setMode(e.target.value)}
                      style={{ accentColor: '#3B82F6' }}
                    />
                    <div>
                      <div style={{ fontWeight: '600', color: '#1F2937' }}>Single Project</div>
                      <div style={{ fontSize: '12px', color: '#6B7280', marginTop: '2px' }}>
                        Fetch data from one specific project
                      </div>
                    </div>
                  </label>
                  <label style={{ display: 'flex', alignItems: 'center', gap: '8px', padding: '12px', border: `2px solid ${mode === 'group' ? '#3B82F6' : '#E5E7EB'}`, borderRadius: '8px', cursor: 'pointer', flex: 1, background: mode === 'group' ? '#EFF6FF' : 'white' }}>
                    <input
                      type="radio"
                      name="mode"
                      value="group"
                      checked={mode === 'group'}
                      onChange={e => setMode(e.target.value)}
                      style={{ accentColor: '#3B82F6' }}
                    />
                    <div>
                      <div style={{ fontWeight: '600', color: '#1F2937' }}>Entire Group</div>
                      <div style={{ fontSize: '12px', color: '#6B7280', marginTop: '2px' }}>
                        Aggregate data from all projects in a group
                      </div>
                    </div>
                  </label>
                </div>
                <div className="text-small text-muted" style={{ marginTop: '8px', padding: '8px', background: '#F0F9FF', borderRadius: '4px', border: '1px solid #BFDBFE' }}>
                  <strong>üí° Tip:</strong> Use <strong>Group Mode</strong> for multi-project pods/teams. This will automatically fetch issues from all projects and subgroups.
                </div>
              </div>

              {mode === 'project' && (
                <div className="form-group">
                  <label className="form-label">Project ID</label>
                  <input
                    type="text"
                    className="form-input"
                    value={projectId}
                    onChange={e => setProjectId(e.target.value)}
                    placeholder="123 or group/project"
                  />
                  <div className="text-small text-muted" style={{ marginTop: '4px' }}>
                    Find this in your GitLab project settings
                  </div>
                </div>
              )}

              <div className="form-group">
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                  <label className="form-label" style={{ marginBottom: 0 }}>
                    {mode === 'group' ? 'Group Path (Required)' : 'Group Paths (Optional)'}
                  </label>
                  {mode === 'project' && (
                    <button
                      type="button"
                      onClick={handleAddGroupPath}
                      style={{
                        padding: '4px 12px',
                        background: '#10B981',
                        color: 'white',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        fontSize: '12px',
                        fontWeight: '500'
                      }}
                    >
                      + Add Group
                    </button>
                  )}
                </div>
                {groupPaths.map((path, index) => (
                  <div key={index} style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                    <input
                      type="text"
                      className="form-input"
                      value={path}
                      onChange={e => handleUpdateGroupPath(index, e.target.value)}
                      placeholder={mode === 'group' ? '12345 or GMDP Nova or parent-group/gmdp-nova' : 'my-group or parent-group/sub-group'}
                      style={{ flex: 1 }}
                    />
                    {mode === 'project' && groupPaths.length > 1 && (
                      <button
                        type="button"
                        onClick={() => handleRemoveGroupPath(index)}
                        style={{
                          padding: '8px 12px',
                          background: '#DC2626',
                          color: 'white',
                          border: 'none',
                          borderRadius: '4px',
                          cursor: 'pointer',
                          fontSize: '12px'
                        }}
                      >
                        Remove
                      </button>
                    )}
                  </div>
                ))}
                <div className="text-small text-muted" style={{ marginTop: '4px' }}>
                  {mode === 'group'
                    ? 'Use numeric group ID (e.g., "12345") or group path (e.g., "GMDP Nova"). All projects in subgroups will be included automatically.'
                    : 'Required for Epic support (Premium/Ultimate only). Add multiple groups to fetch epics from different parts of your hierarchy.'
                  }
                </div>
              </div>

              {/* Centralized Token Field */}
              <div className="form-group" style={{ background: '#F0F9FF', padding: '16px', borderRadius: '8px', border: '1px solid #93C5FD' }}>
                <label className="form-label" style={{ color: '#1E40AF', marginBottom: '8px', fontWeight: '600', fontSize: '15px' }}>
                  üîê GitLab Access Token (Required)
                </label>
                <input
                  type="password"
                  className="form-input"
                  value={token}
                  onChange={e => setToken(e.target.value)}
                  placeholder="glpat-xxxxxxxxxxxxxxxxxxxx"
                  style={{ marginBottom: '12px', fontSize: '14px' }}
                />
                <div style={{ background: 'white', padding: '12px', borderRadius: '6px', border: '1px solid #DBEAFE' }}>
                  <div style={{ marginBottom: '8px', color: '#1E40AF', fontWeight: '500' }}>
                    ‚ú® This single token is automatically used everywhere:
                  </div>
                  <ul style={{ margin: '0', paddingLeft: '20px', color: '#3B82F6', fontSize: '13px' }}>
                    <li>All projects in the Projects tab</li>
                    <li>All pods/groups in the Pods tab</li>
                    <li>Current connection settings</li>
                    <li>Cross-project data aggregation</li>
                  </ul>
                </div>
                <div className="text-small text-muted" style={{ marginTop: '12px' }}>
                  <div style={{ marginBottom: '6px' }}>
                    <strong>Required Scopes:</strong> <code>api</code> and <code>read_api</code>
                  </div>
                  <div style={{ color: '#DC2626', fontSize: '13px', marginBottom: '6px' }}>
                    ‚ö†Ô∏è <strong>For Epic support:</strong> Token must have group-level access
                  </div>
                  <div style={{ fontSize: '12px' }}>
                    üìç Create at: GitLab ‚Üí User Settings ‚Üí Access Tokens (not Project Settings)
                  </div>
                </div>
              </div>

              <div className="form-group">
                <div style={{ display: 'flex', alignItems: 'center', gap: '12px', padding: '12px', background: '#F9FAFB', borderRadius: '8px', border: '1px solid #E5E7EB' }}>
                  <input
                    type="checkbox"
                    id="filter2025"
                    checked={filter2025}
                    onChange={e => setFilter2025(e.target.checked)}
                    style={{ width: '18px', height: '18px', cursor: 'pointer' }}
                  />
                  <label htmlFor="filter2025" style={{ cursor: 'pointer', flex: 1, margin: 0 }}>
                    <div style={{ fontSize: '14px', fontWeight: '600', color: '#1F2937', marginBottom: '4px' }}>
                      Filter data by year 2025+
                    </div>
                    <div className="text-small text-muted">
                      When enabled, only shows issues, epics, and milestones with dates {'>='} 2025-01-01
                    </div>
                  </label>
                </div>
              </div>
            </>
          )}

          {activeTab === 'projects' && (
            <>
              <div style={{ marginBottom: '20px' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
                  <div>
                    <h3 style={{ fontSize: '16px', fontWeight: '600', marginBottom: '4px' }}>
                      Manage Projects
                    </h3>
                    <p style={{ fontSize: '13px', color: '#6B7280' }}>
                      Add multiple projects and switch between them
                    </p>
                  </div>
                  <button
                    className="btn btn-primary"
                    onClick={() => {
                      if (showAddForm) {
                        handleCancelEdit()
                      } else {
                        setShowAddForm(true)
                      }
                    }}
                  >
                    {showAddForm ? 'Cancel' : '+ Add Project'}
                  </button>
                </div>

                {showAddForm && (
                  <div className="card" style={{ padding: '20px', marginBottom: '20px', background: '#F9FAFB' }}>
                    <h4 style={{ fontSize: '14px', fontWeight: '600', marginBottom: '16px' }}>
                      {editingProject ? 'Edit Project' : 'Add New Project'}
                    </h4>

                    <div className="form-group">
                      <label className="form-label">Project Name</label>
                      <input
                        type="text"
                        className="form-input"
                        value={formData.name}
                        onChange={e => setFormData({ ...formData, name: e.target.value })}
                        placeholder="My Project"
                      />
                    </div>

                    <div className="form-group">
                      <label className="form-label">GitLab URL</label>
                      <input
                        type="text"
                        className="form-input"
                        value={formData.gitlabUrl}
                        onChange={e => setFormData({ ...formData, gitlabUrl: e.target.value })}
                        placeholder="https://gitlab.com"
                      />
                    </div>

                    <div className="form-group">
                      <label className="form-label">Project ID</label>
                      <input
                        type="text"
                        className="form-input"
                        value={formData.projectId}
                        onChange={e => setFormData({ ...formData, projectId: e.target.value })}
                        placeholder="123 or group/project"
                      />
                    </div>

                    <div className="form-group">
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                        <label className="form-label" style={{ marginBottom: 0 }}>Group Paths (Optional)</label>
                        <button
                          type="button"
                          onClick={handleAddFormGroupPath}
                          style={{
                            padding: '4px 12px',
                            background: '#10B981',
                            color: 'white',
                            border: 'none',
                            borderRadius: '4px',
                            cursor: 'pointer',
                            fontSize: '12px',
                            fontWeight: '500'
                          }}
                        >
                          + Add Group
                        </button>
                      </div>
                      {formData.groupPaths.map((path, index) => (
                        <div key={index} style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                          <input
                            type="text"
                            className="form-input"
                            value={path}
                            onChange={e => handleUpdateFormGroupPath(index, e.target.value)}
                            placeholder="my-group or parent-group/sub-group"
                            style={{ flex: 1 }}
                          />
                          {formData.groupPaths.length > 1 && (
                            <button
                              type="button"
                              onClick={() => handleRemoveFormGroupPath(index)}
                              style={{
                                padding: '8px 12px',
                                background: '#DC2626',
                                color: 'white',
                                border: 'none',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                fontSize: '12px'
                              }}
                            >
                              Remove
                            </button>
                          )}
                        </div>
                      ))}
                    </div>

                    <div style={{ display: 'flex', gap: '8px', justifyContent: 'flex-end' }}>
                      <button className="btn" onClick={handleCancelEdit}>
                        Cancel
                      </button>
                      <button className="btn btn-primary" onClick={handleAddProject}>
                        {editingProject ? 'Update' : 'Add'} Project
                      </button>
                    </div>
                  </div>
                )}

                {projects.length === 0 ? (
                  <div className="card text-center" style={{ padding: '40px' }}>
                    <div style={{ fontSize: '48px', marginBottom: '16px', opacity: 0.3 }}>üìÅ</div>
                    <h3 className="mb-2">No Projects</h3>
                    <p className="text-muted">
                      Add your first project to get started
                    </p>
                  </div>
                ) : (
                  <div style={{ display: 'grid', gap: '12px' }}>
                    {projects.map(project => (
                      <div
                        key={project.id}
                        className="card"
                        style={{ padding: '16px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}
                      >
                        <div>
                          <h4 style={{ fontSize: '16px', fontWeight: '600', marginBottom: '4px' }}>
                            {project.name}
                          </h4>
                          <p style={{ fontSize: '13px', color: '#6B7280', marginBottom: '4px' }}>
                            {project.projectId} ¬∑ {project.gitlabUrl}
                          </p>
                        </div>
                        <div style={{ display: 'flex', gap: '8px' }}>
                          <button
                            className="btn"
                            onClick={() => handleSwitchProject(project.id)}
                            style={{ fontSize: '13px' }}
                          >
                            Switch To
                          </button>
                          <button
                            className="btn"
                            onClick={() => handleEditProject(project)}
                            style={{ fontSize: '13px' }}
                          >
                            Edit
                          </button>
                          <button
                            className="btn"
                            onClick={() => handleRemoveProject(project.id)}
                            style={{ fontSize: '13px', color: '#DC2626' }}
                          >
                            Remove
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </>
          )}

          {activeTab === 'groups' && (
            <ProjectGroupManager
              onSelect={(groupId) => {
                // Switch to the project group
                if (onProjectSwitch) {
                  setActiveProject(`group:${groupId}`)
                  onProjectSwitch(`group:${groupId}`)
                  onClose()
                }
              }}
              onClose={onClose}
            />
          )}

          {activeTab === 'pods' && (
            <>
              <div style={{ marginBottom: '20px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <div>
                  <h3 style={{ margin: 0, marginBottom: '4px' }}>GitLab Groups (Pods)</h3>
                  <p style={{ margin: 0, fontSize: '14px', color: 'var(--text-muted)' }}>
                    Configure multiple GitLab groups to track different teams/pods separately
                  </p>
                </div>
                <button
                  onClick={() => setShowAddGroupForm(!showAddGroupForm)}
                  style={{
                    padding: '8px 16px',
                    background: showAddGroupForm ? '#6B7280' : '#3B82F6',
                    color: 'white',
                    border: 'none',
                    borderRadius: '6px',
                    cursor: 'pointer',
                    fontWeight: '600'
                  }}
                >
                  {showAddGroupForm ? 'Cancel' : '+ Add Pod'}
                </button>
              </div>

              {showAddGroupForm && (
                <div style={{
                  background: '#F9FAFB',
                  padding: '20px',
                  borderRadius: '8px',
                  marginBottom: '20px',
                  border: '1px solid #E5E7EB'
                }}>
                  <h4 style={{ marginTop: 0 }}>
                    {editingGroup ? 'Edit Pod' : 'Add New Pod'}
                  </h4>

                  <div className="form-group">
                    <label className="form-label">Pod Name</label>
                    <input
                      type="text"
                      className="form-input"
                      value={groupFormData.name}
                      onChange={e => setGroupFormData({ ...groupFormData, name: e.target.value })}
                      placeholder="e.g., Nova Pod, Astro Team"
                    />
                  </div>

                  <div className="form-group">
                    <label className="form-label">GitLab URL</label>
                    <input
                      type="text"
                      className="form-input"
                      value={groupFormData.gitlabUrl}
                      onChange={e => setGroupFormData({ ...groupFormData, gitlabUrl: e.target.value })}
                      placeholder="https://gitlab.com"
                    />
                  </div>

                  <div className="form-group">
                    <label className="form-label">Group ID or Path</label>
                    <input
                      type="text"
                      className="form-input"
                      value={groupFormData.groupPath}
                      onChange={e => setGroupFormData({ ...groupFormData, groupPath: e.target.value })}
                      placeholder="12345 or GMDP Nova or parent-group/gmdp-nova"
                    />
                    <div className="text-small text-muted" style={{ marginTop: '4px' }}>
                      Use numeric group ID (e.g., "12345") or group path (e.g., "GMDP Nova"). All projects in subgroups will be included automatically.
                    </div>
                  </div>

                  <div style={{ display: 'flex', gap: '8px' }}>
                    <button
                      onClick={handleAddGroup}
                      style={{
                        flex: 1,
                        padding: '10px',
                        background: '#3B82F6',
                        color: 'white',
                        border: 'none',
                        borderRadius: '6px',
                        cursor: 'pointer',
                        fontWeight: '600'
                      }}
                    >
                      {editingGroup ? 'Update Pod' : 'Add Pod'}
                    </button>
                    <button
                      onClick={handleCancelGroupEdit}
                      style={{
                        padding: '10px 20px',
                        background: '#6B7280',
                        color: 'white',
                        border: 'none',
                        borderRadius: '6px',
                        cursor: 'pointer'
                      }}
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              )}

              {groups.length === 0 ? (
                <div style={{
                  padding: '40px',
                  textAlign: 'center',
                  background: '#F9FAFB',
                  borderRadius: '8px',
                  border: '1px solid #E5E7EB',
                  color: '#6B7280'
                }}>
                  <div style={{ fontSize: '48px', marginBottom: '12px' }}>üè¢</div>
                  <div style={{ fontSize: '16px', fontWeight: '600', marginBottom: '4px', color: '#374151' }}>
                    No Pods Configured
                  </div>
                  <div style={{ fontSize: '14px' }}>
                    Add your first GitLab group to track team metrics
                  </div>
                </div>
              ) : (
                <div style={{ display: 'grid', gap: '12px' }}>
                  {groups.map(group => (
                    <div
                      key={group.id}
                      style={{
                        padding: '16px',
                        background: 'white',
                        border: '1px solid #E5E7EB',
                        borderRadius: '8px'
                      }}
                    >
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
                        <div style={{ flex: 1 }}>
                          <h4 style={{ margin: 0, marginBottom: '4px' }}>{group.name}</h4>
                          <div style={{ fontSize: '13px', color: '#6B7280', fontFamily: 'monospace' }}>
                            {group.groupPath}
                          </div>
                          <div style={{ fontSize: '12px', color: '#9CA3AF', marginTop: '4px' }}>
                            {group.gitlabUrl}
                          </div>
                        </div>
                        <div style={{ display: 'flex', gap: '8px' }}>
                          <button
                            onClick={() => handleSwitchGroup(group.id)}
                            style={{
                              padding: '6px 12px',
                              background: '#10B981',
                              color: 'white',
                              border: 'none',
                              borderRadius: '4px',
                              cursor: 'pointer',
                              fontSize: '13px',
                              fontWeight: '500'
                            }}
                          >
                            View
                          </button>
                          <button
                            onClick={() => handleEditGroup(group)}
                            style={{
                              padding: '6px 12px',
                              background: '#3B82F6',
                              color: 'white',
                              border: 'none',
                              borderRadius: '4px',
                              cursor: 'pointer',
                              fontSize: '13px'
                            }}
                          >
                            Edit
                          </button>
                          <button
                            onClick={() => handleRemoveGroup(group.id)}
                            style={{
                              padding: '6px 12px',
                              background: '#DC2626',
                              color: 'white',
                              border: 'none',
                              borderRadius: '4px',
                              cursor: 'pointer',
                              fontSize: '13px'
                            }}
                          >
                            Delete
                          </button>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </>
          )}
        </div>

        <div className="modal-footer">
          <button className="btn" onClick={onClose}>
            Close
          </button>
          {activeTab === 'connection' && (
            <button
              className="btn btn-primary"
              onClick={handleSave}
              disabled={
                !gitlabUrl ||
                !token ||
                (mode === 'project' && !projectId) ||
                (mode === 'group' && groupPaths.filter(p => p.trim()).length === 0)
              }
            >
              Save Configuration
            </button>
          )}
        </div>
      </div>
    </div>
  )
}

```

---


## FILE: src/services/storageService.js

```javascript
/**
 * LocalStorage Service
 * Handles all browser storage operations
 */

const KEYS = {
  GITLAB_URL: 'gitlab_url',
  GITLAB_TOKEN: 'gitlab_token',
  PROJECT_ID: 'gitlab_project',
  GROUP_PATH: 'gitlab_group_path',
  FILTER_2025: 'gitlab_filter_2025',
  MODE: 'gitlab_mode', // 'project' or 'group'
  RISKS: 'project_risks',
  PROJECTS: 'portfolio_projects', // Multi-project configuration
  ACTIVE_PROJECT: 'active_project_id', // Currently active project
  GROUPS: 'portfolio_groups', // Multi-group configuration (for pods)
  ACTIVE_GROUP: 'active_group_id' // Currently active group
}

/**
 * Save GitLab configuration
 */
export function saveConfig(config) {
  localStorage.setItem(KEYS.GITLAB_URL, config.gitlabUrl || '')
  localStorage.setItem(KEYS.GITLAB_TOKEN, config.token || '')
  localStorage.setItem(KEYS.PROJECT_ID, config.projectId || '')
  localStorage.setItem(KEYS.GROUP_PATH, config.groupPath || '')
  localStorage.setItem(KEYS.MODE, config.mode || 'project')
  // Save filter2025 setting (store as string to handle boolean properly)
  if (config.filter2025 !== undefined) {
    localStorage.setItem(KEYS.FILTER_2025, config.filter2025.toString())
  }
}

/**
 * Load GitLab configuration
 */
export function loadConfig() {
  // Load filter2025 setting from localStorage (default to false if not set)
  const filter2025Stored = localStorage.getItem(KEYS.FILTER_2025)
  const filter2025 = filter2025Stored !== null ? filter2025Stored === 'true' : false

  const mode = localStorage.getItem(KEYS.MODE) || 'project'

  return {
    gitlabUrl: localStorage.getItem(KEYS.GITLAB_URL) || 'https://gitlab.com',
    token: localStorage.getItem(KEYS.GITLAB_TOKEN) || '',
    projectId: localStorage.getItem(KEYS.PROJECT_ID) || '',
    groupPath: localStorage.getItem(KEYS.GROUP_PATH) || '',
    mode,
    filter2025
  }
}

/**
 * Check if configuration is complete
 */
export function isConfigured() {
  const config = loadConfig()

  // In group mode, groupPath is required instead of projectId
  if (config.mode === 'group') {
    return !!(config.gitlabUrl && config.token && config.groupPath)
  }

  // In project mode, projectId is required
  return !!(config.gitlabUrl && config.token && config.projectId)
}

/**
 * Clear all stored configuration
 */
export function clearConfig() {
  localStorage.removeItem(KEYS.GITLAB_URL)
  localStorage.removeItem(KEYS.GITLAB_TOKEN)
  localStorage.removeItem(KEYS.PROJECT_ID)
  localStorage.removeItem(KEYS.GROUP_PATH)
  localStorage.removeItem(KEYS.MODE)
  localStorage.removeItem(KEYS.FILTER_2025)
}

/**
 * Load risks from storage
 */
export function loadRisks() {
  const stored = localStorage.getItem(KEYS.RISKS)
  return stored ? JSON.parse(stored) : []
}

/**
 * Save risks to storage
 */
export function saveRisks(risks) {
  localStorage.setItem(KEYS.RISKS, JSON.stringify(risks))
}

/**
 * Clear all data (config + risks)
 */
export function clearAll() {
  localStorage.clear()
}

/**
 * PORTFOLIO MANAGEMENT
 */

/**
 * Get all configured projects
 */
export function getAllProjects() {
  const stored = localStorage.getItem(KEYS.PROJECTS)
  return stored ? JSON.parse(stored) : []
}

/**
 * Save project to portfolio
 */
export function saveProject(project) {
  const projects = getAllProjects()
  const existingIndex = projects.findIndex(p => p.id === project.id)

  if (existingIndex >= 0) {
    // Update existing project
    projects[existingIndex] = { ...projects[existingIndex], ...project }
  } else {
    // Add new project
    projects.push({
      id: project.id || Date.now().toString(),
      name: project.name,
      gitlabUrl: project.gitlabUrl,
      projectId: project.projectId,
      groupPath: project.groupPath || '',
      addedAt: new Date().toISOString()
    })
  }

  localStorage.setItem(KEYS.PROJECTS, JSON.stringify(projects))
  return projects
}

/**
 * Remove project from portfolio
 */
export function removeProject(projectId) {
  const projects = getAllProjects()
  const filtered = projects.filter(p => p.id !== projectId)
  localStorage.setItem(KEYS.PROJECTS, JSON.stringify(filtered))
  return filtered
}

/**
 * Get active project ID
 */
export function getActiveProjectId() {
  return localStorage.getItem(KEYS.ACTIVE_PROJECT)
}

/**
 * Set active project
 */
export function setActiveProject(projectId) {
  localStorage.setItem(KEYS.ACTIVE_PROJECT, projectId)

  // Also update the current config for backwards compatibility
  const projects = getAllProjects()
  const project = projects.find(p => p.id === projectId)

  if (project) {
    saveConfig({
      gitlabUrl: project.gitlabUrl,
      token: project.token,
      projectId: project.projectId,
      groupPath: project.groupPath
    })
  }
}

/**
 * Get active project configuration
 */
export function getActiveProject() {
  const activeId = getActiveProjectId()
  if (!activeId) return null

  const projects = getAllProjects()
  return projects.find(p => p.id === activeId) || null
}

/**
 * GROUP MANAGEMENT (for multi-pod configurations)
 */

/**
 * Get all configured groups
 */
export function getAllGroups() {
  const stored = localStorage.getItem(KEYS.GROUPS)
  return stored ? JSON.parse(stored) : []
}

/**
 * Save group to portfolio
 */
export function saveGroup(group) {
  const groups = getAllGroups()
  const existingIndex = groups.findIndex(g => g.id === group.id)

  if (existingIndex >= 0) {
    // Update existing group
    groups[existingIndex] = { ...groups[existingIndex], ...group }
  } else {
    // Add new group
    groups.push({
      id: group.id || Date.now().toString(),
      name: group.name,
      gitlabUrl: group.gitlabUrl,
      groupPath: group.groupPath,
      addedAt: new Date().toISOString()
    })
  }

  localStorage.setItem(KEYS.GROUPS, JSON.stringify(groups))
  return groups
}

/**
 * Remove group from portfolio
 */
export function removeGroup(groupId) {
  const groups = getAllGroups()
  const filtered = groups.filter(g => g.id !== groupId)
  localStorage.setItem(KEYS.GROUPS, JSON.stringify(filtered))
  return filtered
}

/**
 * Get active group ID
 */
export function getActiveGroupId() {
  return localStorage.getItem(KEYS.ACTIVE_GROUP)
}

/**
 * Set active group
 */
export function setActiveGroup(groupId) {
  localStorage.setItem(KEYS.ACTIVE_GROUP, groupId)

  // Also update the current config for backwards compatibility
  const groups = getAllGroups()
  const group = groups.find(g => g.id === groupId)

  if (group) {
    saveConfig({
      gitlabUrl: group.gitlabUrl,
      token: group.token,
      groupPath: group.groupPath,
      mode: 'group'
    })
  }
}

/**
 * Get active group configuration
 */
export function getActiveGroup() {
  const activeId = getActiveGroupId()
  if (!activeId) return null

  const groups = getAllGroups()
  return groups.find(g => g.id === activeId) || null
}

```

---


## FILE: src/services/backupService.js

```javascript
/**
 * Backup and Restore Service
 * Manages comprehensive application data backup and restore
 * Enables team collaboration by sharing configurations without a server
 */

const BACKUP_VERSION = '1.0.0'

/**
 * Get all localStorage keys used by the application
 */
function getAllStorageKeys() {
  return {
    // Core GitLab configuration
    gitlabUrl: 'gitlab_url',
    gitlabToken: 'gitlab_token',
    projectId: 'gitlab_project',
    groupPath: 'gitlab_group_path',
    filter2025: 'gitlab_filter_2025',
    mode: 'gitlab_mode',

    // Portfolio/Multi-project
    portfolioProjects: 'portfolio_projects',
    activeProject: 'active_project_id',

    // Project Groups
    projectGroups: 'gitlab-pm-project-groups',

    // Pods/Multi-group
    portfolioGroups: 'portfolio_groups',
    activeGroup: 'active_group_id',

    // Risk management
    risks: 'project_risks',

    // Team configuration (base keys - per-project variants handled dynamically)
    teamConfigBase: 'gitlab_team_config',
    sprintCapacityBase: 'gitlab_sprint_capacity',
    capacitySettingsBase: 'gitlab_capacity_settings',

    // Absences (base key - per-project variants handled dynamically)
    absencesBase: 'gitlab-pm-absences',

    // Stakeholder Hub
    stakeholders: 'stakeholders',
    communicationHistory: 'communication_history',
    communicationTemplates: 'communication_templates',
    stakeholderDecisions: 'decisions',  // Stakeholder hub decisions
    documents: 'documents',

    // Project Decisions (base key - per-project variants handled dynamically)
    projectDecisionsBase: 'gitlab-pm-decisions',

    // Health Score
    healthScoreConfig: 'healthScoreConfig',

    // Quality & Compliance
    criteriaConfig: 'gitlab-pm-quality-criteria-config',
    dodTemplates: 'dodTemplates',

    // Sprint Management
    sprintGoals: 'sprintGoals',
    retroActions: 'retroActions',

    // Release Planning
    releases: 'gitlab-pm-releases',
    featureToggles: 'gitlab-pm-feature-toggles',

    // Forecast Accuracy (base key - per-project variants handled dynamically)
    forecastsBase: 'gitlab-pm-forecasts',

    // Backlog Health
    backlogHealthHistory: 'backlogHealthHistory',

    // User Preferences
    userRole: 'user_role',
    viewPreference: 'view_preference',
    favoriteViews: 'favorite_views',

    // Velocity Configuration
    velocityConfig: 'velocityConfig',

    // UI State
    qualityShowOpenOnly: 'quality.showOpenOnly',
    qualityLegendCollapsed: 'quality.legendCollapsed',
    cycleTimeBottleneckCollapsed: 'cycleTime.bottleneckCollapsed'
  }
}

/**
 * Get all per-project and per-pod keys for a base key pattern
 * @param {string} baseKey - Base key pattern (e.g., 'gitlab_team_config')
 * @returns {Object} Map with project and pod keys separated
 */
function getPerProjectKeys(baseKey) {
  const result = {
    projectKeys: {},
    podKeys: {}
  }

  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i)
    if (key && key.startsWith(baseKey)) {
      if (key === baseKey) {
        // Base key without suffix (default/global)
        result.projectKeys['default'] = key
      } else if (key.startsWith(`${baseKey}_pod_`)) {
        // Pod-level key
        const podId = key.substring(`${baseKey}_pod_`.length)
        result.podKeys[podId] = key
      } else if (key.startsWith(`${baseKey}_`)) {
        // Project-level key (but not pod)
        const projectId = key.substring(baseKey.length + 1)
        // Skip if it's actually a pod key that we already captured
        if (!projectId.startsWith('pod_')) {
          result.projectKeys[projectId] = key
        }
      }
    }
  }

  return result
}

/**
 * Load data from localStorage
 */
function loadFromStorage(key) {
  try {
    const data = localStorage.getItem(key)
    return data ? JSON.parse(data) : null
  } catch (e) {
    console.warn(`Failed to load ${key}:`, e)
    return null
  }
}

/**
 * Save data to localStorage
 */
function saveToStorage(key, data) {
  try {
    localStorage.setItem(key, JSON.stringify(data))
    return true
  } catch (e) {
    console.error(`Failed to save ${key}:`, e)
    return false
  }
}

/**
 * Mask sensitive data (access tokens)
 */
function maskToken(token) {
  if (!token || token.length < 8) return '***'
  return token.substring(0, 4) + '***' + token.substring(token.length - 4)
}

/**
 * Create a complete backup of application data
 * @param {Object} options - Backup options
 * @param {boolean} options.includeTokens - Include access tokens (default: false for security)
 * @param {boolean} options.encrypt - Encrypt backup (future feature)
 * @param {string} options.password - Encryption password (future feature)
 * @returns {Object} Backup object
 */
export function createBackup(options = {}) {
  const { includeTokens = false, encrypt = false, password = null } = options

  const keys = getAllStorageKeys()
  const includedData = []
  const data = {}

  // Helper to add data if it exists
  const addIfExists = (category, storageKey, transform = null) => {
    const value = loadFromStorage(storageKey)
    if (value !== null) {
      data[category] = transform ? transform(value) : value
      includedData.push(category)
    }
  }

  // 1. Core GitLab Configuration
  const gitlabToken = loadFromStorage(keys.gitlabToken)
  const gitlabUrl = loadFromStorage(keys.gitlabUrl)
  const projectId = loadFromStorage(keys.projectId)
  const groupPath = loadFromStorage(keys.groupPath)
  const filter2025 = loadFromStorage(keys.filter2025)
  const mode = loadFromStorage(keys.mode)

  if (gitlabToken || gitlabUrl || projectId || groupPath || filter2025 || mode) {
    data.gitlabConfig = {
      gitlabUrl,
      gitlabToken: includeTokens ? gitlabToken : (gitlabToken ? maskToken(gitlabToken) : null),
      projectId,
      groupPath,
      filter2025,
      mode
    }
    includedData.push('gitlabConfig')
  }

  // 2. Portfolio/Multi-project Configuration
  const portfolioProjects = loadFromStorage(keys.portfolioProjects)
  if (portfolioProjects) {
    // Remove token field from projects since we use centralized token
    if (Array.isArray(portfolioProjects)) {
      data.portfolioProjects = portfolioProjects.map(p => {
        const { token, ...projectWithoutToken } = p
        return projectWithoutToken
      })
    } else {
      data.portfolioProjects = portfolioProjects
    }
    includedData.push('portfolioProjects')
  }

  addIfExists('activeProject', keys.activeProject)

  // 3. Project Groups
  addIfExists('projectGroups', keys.projectGroups)

  // 4. Pods/Multi-group Configuration
  const portfolioGroups = loadFromStorage(keys.portfolioGroups)
  if (portfolioGroups) {
    // Remove token field from groups since we use centralized token
    if (Array.isArray(portfolioGroups)) {
      data.portfolioGroups = portfolioGroups.map(g => {
        const { token, ...groupWithoutToken } = g
        return groupWithoutToken
      })
    } else {
      data.portfolioGroups = portfolioGroups
    }
    includedData.push('portfolioGroups')
  }

  addIfExists('activeGroup', keys.activeGroup)

  // 5. Risk Management
  addIfExists('risks', keys.risks)

  // 6. Team Configuration (per-project and per-pod)
  const teamConfigKeys = getPerProjectKeys(keys.teamConfigBase)
  const sprintCapacityKeys = getPerProjectKeys(keys.sprintCapacityBase)
  const capacitySettingsKeys = getPerProjectKeys(keys.capacitySettingsBase)

  const hasTeamData =
    Object.keys(teamConfigKeys.projectKeys).length > 0 ||
    Object.keys(teamConfigKeys.podKeys).length > 0 ||
    Object.keys(sprintCapacityKeys.projectKeys).length > 0 ||
    Object.keys(sprintCapacityKeys.podKeys).length > 0 ||
    Object.keys(capacitySettingsKeys.projectKeys).length > 0 ||
    Object.keys(capacitySettingsKeys.podKeys).length > 0

  if (hasTeamData) {
    data.teamConfiguration = {
      projectLevel: {
        teamConfigs: {},
        sprintCapacities: {},
        capacitySettings: {}
      },
      podLevel: {
        teamConfigs: {},
        sprintCapacities: {},
        capacitySettings: {}
      }
    }

    // Load project-level team configs
    Object.entries(teamConfigKeys.projectKeys).forEach(([projectId, key]) => {
      const config = loadFromStorage(key)
      if (config) {
        data.teamConfiguration.projectLevel.teamConfigs[projectId] = config
      }
    })

    // Load pod-level team configs
    Object.entries(teamConfigKeys.podKeys).forEach(([podId, key]) => {
      const config = loadFromStorage(key)
      if (config) {
        data.teamConfiguration.podLevel.teamConfigs[podId] = config
      }
    })

    // Load project-level sprint capacities
    Object.entries(sprintCapacityKeys.projectKeys).forEach(([projectId, key]) => {
      const capacity = loadFromStorage(key)
      if (capacity) {
        data.teamConfiguration.projectLevel.sprintCapacities[projectId] = capacity
      }
    })

    // Load pod-level sprint capacities
    Object.entries(sprintCapacityKeys.podKeys).forEach(([podId, key]) => {
      const capacity = loadFromStorage(key)
      if (capacity) {
        data.teamConfiguration.podLevel.sprintCapacities[podId] = capacity
      }
    })

    // Load project-level capacity settings
    Object.entries(capacitySettingsKeys.projectKeys).forEach(([projectId, key]) => {
      const settings = loadFromStorage(key)
      if (settings) {
        data.teamConfiguration.projectLevel.capacitySettings[projectId] = settings
      }
    })

    // Load pod-level capacity settings
    Object.entries(capacitySettingsKeys.podKeys).forEach(([podId, key]) => {
      const settings = loadFromStorage(key)
      if (settings) {
        data.teamConfiguration.podLevel.capacitySettings[podId] = settings
      }
    })

    // Check if we actually have data
    const hasProjectData =
      Object.keys(data.teamConfiguration.projectLevel.teamConfigs).length > 0 ||
      Object.keys(data.teamConfiguration.projectLevel.sprintCapacities).length > 0 ||
      Object.keys(data.teamConfiguration.projectLevel.capacitySettings).length > 0

    const hasPodData =
      Object.keys(data.teamConfiguration.podLevel.teamConfigs).length > 0 ||
      Object.keys(data.teamConfiguration.podLevel.sprintCapacities).length > 0 ||
      Object.keys(data.teamConfiguration.podLevel.capacitySettings).length > 0

    if (hasProjectData || hasPodData) {
      includedData.push('teamConfiguration')
    } else {
      delete data.teamConfiguration
    }
  }

  // 7. Absences (per-project and per-pod)
  const absenceKeys = getPerProjectKeys(keys.absencesBase)

  const hasAbsenceData =
    Object.keys(absenceKeys.projectKeys).length > 0 ||
    Object.keys(absenceKeys.podKeys).length > 0

  if (hasAbsenceData) {
    data.absences = {
      projectLevel: {},
      podLevel: {}
    }

    // Load project-level absences
    Object.entries(absenceKeys.projectKeys).forEach(([projectId, key]) => {
      const absenceData = loadFromStorage(key)
      if (absenceData) {
        data.absences.projectLevel[projectId] = absenceData
      }
    })

    // Load pod-level absences
    Object.entries(absenceKeys.podKeys).forEach(([podId, key]) => {
      const absenceData = loadFromStorage(key)
      if (absenceData) {
        data.absences.podLevel[podId] = absenceData
      }
    })

    const hasProjectAbsences = Object.keys(data.absences.projectLevel).length > 0
    const hasPodAbsences = Object.keys(data.absences.podLevel).length > 0

    if (hasProjectAbsences || hasPodAbsences) {
      includedData.push('absences')
    } else {
      delete data.absences
    }
  }

  // 8. Stakeholder Hub Data
  const stakeholders = loadFromStorage(keys.stakeholders)
  const communicationHistory = loadFromStorage(keys.communicationHistory)
  const communicationTemplates = loadFromStorage(keys.communicationTemplates)
  const stakeholderDecisions = loadFromStorage(keys.stakeholderDecisions)
  const documents = loadFromStorage(keys.documents)

  if (stakeholders || communicationHistory || communicationTemplates || stakeholderDecisions || documents) {
    data.stakeholderHub = {
      stakeholders,
      communicationHistory,
      communicationTemplates,
      decisions: stakeholderDecisions,  // Keep as 'decisions' for backward compatibility
      documents
    }
    includedData.push('stakeholderHub')
  }

  // 9. Project Decisions (per-project)
  const projectDecisionKeys = getPerProjectKeys(keys.projectDecisionsBase)
  const hasProjectDecisions =
    Object.keys(projectDecisionKeys.projectKeys).length > 0 ||
    Object.keys(projectDecisionKeys.podKeys).length > 0

  if (hasProjectDecisions) {
    data.projectDecisions = {
      projectLevel: {},
      podLevel: {}
    }

    // Load project-level decisions
    Object.entries(projectDecisionKeys.projectKeys).forEach(([projectId, key]) => {
      const decisionData = loadFromStorage(key)
      if (decisionData) {
        data.projectDecisions.projectLevel[projectId] = decisionData
      }
    })

    // Load pod-level decisions
    Object.entries(projectDecisionKeys.podKeys).forEach(([podId, key]) => {
      const decisionData = loadFromStorage(key)
      if (decisionData) {
        data.projectDecisions.podLevel[podId] = decisionData
      }
    })

    const hasProjectData = Object.keys(data.projectDecisions.projectLevel).length > 0
    const hasPodData = Object.keys(data.projectDecisions.podLevel).length > 0

    if (hasProjectData || hasPodData) {
      includedData.push('projectDecisions')
    } else {
      delete data.projectDecisions
    }
  }

  // 10. Health Score Configuration
  addIfExists('healthScoreConfig', keys.healthScoreConfig)

  // 11. Quality & Compliance
  addIfExists('criteriaConfig', keys.criteriaConfig)
  addIfExists('dodTemplates', keys.dodTemplates)

  // 12. Sprint Management
  addIfExists('sprintGoals', keys.sprintGoals)
  addIfExists('retroActions', keys.retroActions)

  // 13. Release Planning
  addIfExists('releases', keys.releases)
  addIfExists('featureToggles', keys.featureToggles)

  // 14. Forecast Accuracy (per-project)
  const forecastKeys = getPerProjectKeys(keys.forecastsBase)
  const hasForecastData =
    Object.keys(forecastKeys.projectKeys).length > 0 ||
    Object.keys(forecastKeys.podKeys).length > 0

  if (hasForecastData) {
    data.forecasts = {
      projectLevel: {},
      podLevel: {}
    }

    // Load project-level forecasts
    Object.entries(forecastKeys.projectKeys).forEach(([projectId, key]) => {
      const forecastData = loadFromStorage(key)
      if (forecastData) {
        data.forecasts.projectLevel[projectId] = forecastData
      }
    })

    // Load pod-level forecasts
    Object.entries(forecastKeys.podKeys).forEach(([podId, key]) => {
      const forecastData = loadFromStorage(key)
      if (forecastData) {
        data.forecasts.podLevel[podId] = forecastData
      }
    })

    const hasProjectForecasts = Object.keys(data.forecasts.projectLevel).length > 0
    const hasPodForecasts = Object.keys(data.forecasts.podLevel).length > 0

    if (hasProjectForecasts || hasPodForecasts) {
      includedData.push('forecasts')
    } else {
      delete data.forecasts
    }
  }

  // 15. Backlog Health
  addIfExists('backlogHealthHistory', keys.backlogHealthHistory)

  // 16. User Preferences
  addIfExists('userRole', keys.userRole)
  addIfExists('viewPreference', keys.viewPreference)
  addIfExists('favoriteViews', keys.favoriteViews)

  // 17. Velocity Configuration
  addIfExists('velocityConfig', keys.velocityConfig)

  // 18. UI State
  const uiState = {}
  const qualityShowOpenOnly = loadFromStorage(keys.qualityShowOpenOnly)
  const qualityLegendCollapsed = loadFromStorage(keys.qualityLegendCollapsed)
  const cycleTimeBottleneckCollapsed = loadFromStorage(keys.cycleTimeBottleneckCollapsed)

  if (qualityShowOpenOnly !== null || qualityLegendCollapsed !== null || cycleTimeBottleneckCollapsed !== null) {
    uiState.qualityShowOpenOnly = qualityShowOpenOnly
    uiState.qualityLegendCollapsed = qualityLegendCollapsed
    uiState.cycleTimeBottleneckCollapsed = cycleTimeBottleneckCollapsed
    data.uiState = uiState
    includedData.push('uiState')
  }

  // Create backup object
  const backup = {
    metadata: {
      version: BACKUP_VERSION,
      timestamp: new Date().toISOString(),
      appVersion: '1.0.0',
      backupType: encrypt ? 'encrypted' : 'plain',
      includedData,
      tokensIncluded: includeTokens,
      itemCount: Object.keys(data).length
    },
    data
  }

  return backup
}

/**
 * Export backup to downloadable file
 * @param {Object} backup - Backup object from createBackup()
 * @param {string} filename - Optional custom filename
 * @returns {string} Downloaded filename
 */
export function exportBackupToFile(backup, filename = null) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5)
  const defaultFilename = `gitlab-pm-backup-${timestamp}.json`

  const blob = new Blob([JSON.stringify(backup, null, 2)], {
    type: 'application/json'
  })

  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename || defaultFilename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)

  return filename || defaultFilename
}

/**
 * Import backup from file
 * @param {File} file - File object from input
 * @returns {Promise<Object>} Parsed backup object
 */
export async function importBackupFromFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()

    reader.onload = (e) => {
      try {
        const backup = JSON.parse(e.target.result)

        // Validate backup structure
        if (!backup.metadata || !backup.data) {
          reject(new Error('Invalid backup file structure'))
          return
        }

        // Check version compatibility
        if (backup.metadata.version !== BACKUP_VERSION) {
          console.warn(`Backup version ${backup.metadata.version} may not be fully compatible with current version ${BACKUP_VERSION}`)
        }

        resolve(backup)
      } catch (error) {
        reject(new Error('Failed to parse backup file: ' + error.message))
      }
    }

    reader.onerror = () => {
      reject(new Error('Failed to read file'))
    }

    reader.readAsText(file)
  })
}

/**
 * Validate backup before restore
 * @param {Object} backup - Backup object
 * @returns {Object} Validation result with warnings/errors
 */
export function validateBackup(backup) {
  const result = {
    valid: true,
    warnings: [],
    errors: [],
    info: {}
  }

  // Check structure
  if (!backup.metadata || !backup.data) {
    result.valid = false
    result.errors.push('Invalid backup structure: missing metadata or data')
    return result
  }

  // Check version
  if (backup.metadata.version !== BACKUP_VERSION) {
    result.warnings.push(`Backup version (${backup.metadata.version}) differs from current version (${BACKUP_VERSION})`)
  }

  // Check if tokens are masked
  if (!backup.metadata.tokensIncluded) {
    let hasMaskedTokens = false

    // Check GitLab config token
    if (backup.data.gitlabConfig && backup.data.gitlabConfig.gitlabToken &&
        backup.data.gitlabConfig.gitlabToken.includes('***')) {
      hasMaskedTokens = true
    }

    // No need to check portfolio projects/groups tokens since we use centralized token

    if (hasMaskedTokens) {
      result.warnings.push('Access token is masked for security - you will need to re-enter it after import')
    }
  }

  // Provide info about backup
  result.info = {
    createdAt: backup.metadata.timestamp,
    itemCount: backup.metadata.itemCount,
    includedData: backup.metadata.includedData || [],
    backupAge: Math.floor((Date.now() - new Date(backup.metadata.timestamp).getTime()) / (1000 * 60 * 60 * 24)) + ' days'
  }

  return result
}

/**
 * Restore data from backup
 * @param {Object} backup - Backup object
 * @param {Object} options - Restore options
 * @param {boolean} options.overwrite - Overwrite existing data (default: true)
 * @param {boolean} options.merge - Merge with existing data (default: false)
 * @param {Array<string>} options.selectiveRestore - Only restore specific data types
 * @returns {Object} Restore result with success/failure counts
 */
export function restoreFromBackup(backup, options = {}) {
  const {
    overwrite = true,
    merge = false,
    selectiveRestore = null
  } = options

  const keys = getAllStorageKeys()
  const result = {
    success: true,
    restored: [],
    failed: [],
    skipped: []
  }

  // Determine which data to restore
  const dataToRestore = selectiveRestore || Object.keys(backup.data)

  // Restore each data category
  dataToRestore.forEach(category => {
    const data = backup.data[category]
    if (!data && data !== false && data !== 0 && data !== '') {
      result.skipped.push(category)
      return
    }

    try {
      switch (category) {
        case 'gitlabConfig':
          if (overwrite || !loadFromStorage(keys.gitlabUrl)) {
            if (data.gitlabUrl) saveToStorage(keys.gitlabUrl, data.gitlabUrl)
            if (data.gitlabToken) saveToStorage(keys.gitlabToken, data.gitlabToken)
            if (data.projectId) saveToStorage(keys.projectId, data.projectId)
            if (data.groupPath) saveToStorage(keys.groupPath, data.groupPath)
            if (data.filter2025 !== null && data.filter2025 !== undefined) saveToStorage(keys.filter2025, data.filter2025)
            if (data.mode) saveToStorage(keys.mode, data.mode)
            result.restored.push('gitlabConfig')
          } else {
            result.skipped.push('gitlabConfig (already exists)')
          }
          break

        case 'portfolioProjects':
          if (overwrite || !loadFromStorage(keys.portfolioProjects)) {
            saveToStorage(keys.portfolioProjects, data)
            result.restored.push('portfolioProjects')
          } else if (merge && Array.isArray(data)) {
            const existing = loadFromStorage(keys.portfolioProjects) || []
            const merged = [...existing, ...data]
            saveToStorage(keys.portfolioProjects, merged)
            result.restored.push('portfolioProjects (merged)')
          } else {
            result.skipped.push('portfolioProjects (already exists)')
          }
          break

        case 'activeProject':
          if (overwrite || !loadFromStorage(keys.activeProject)) {
            saveToStorage(keys.activeProject, data)
            result.restored.push('activeProject')
          }
          break

        case 'projectGroups':
          if (overwrite || !loadFromStorage(keys.projectGroups)) {
            saveToStorage(keys.projectGroups, data)
            result.restored.push('projectGroups')
          } else if (merge && Array.isArray(data)) {
            const existing = loadFromStorage(keys.projectGroups) || []
            const merged = [...existing, ...data]
            saveToStorage(keys.projectGroups, merged)
            result.restored.push('projectGroups (merged)')
          } else {
            result.skipped.push('projectGroups (already exists)')
          }
          break

        case 'portfolioGroups':
          if (overwrite || !loadFromStorage(keys.portfolioGroups)) {
            saveToStorage(keys.portfolioGroups, data)
            result.restored.push('portfolioGroups')
          } else if (merge && Array.isArray(data)) {
            const existing = loadFromStorage(keys.portfolioGroups) || []
            const merged = [...existing, ...data]
            saveToStorage(keys.portfolioGroups, merged)
            result.restored.push('portfolioGroups (merged)')
          } else {
            result.skipped.push('portfolioGroups (already exists)')
          }
          break

        case 'activeGroup':
          if (overwrite || !loadFromStorage(keys.activeGroup)) {
            saveToStorage(keys.activeGroup, data)
            result.restored.push('activeGroup')
          }
          break

        case 'risks':
          if (overwrite || !loadFromStorage(keys.risks)) {
            saveToStorage(keys.risks, data)
            result.restored.push('risks')
          }
          break

        case 'teamConfiguration':
          // Restore project and pod-level team configurations
          let teamConfigCount = 0

          // Handle new structure (projectLevel/podLevel)
          if (data.projectLevel || data.podLevel) {
            // Restore project-level configs
            if (data.projectLevel) {
              if (data.projectLevel.teamConfigs) {
                Object.entries(data.projectLevel.teamConfigs).forEach(([projectId, config]) => {
                  const key = projectId === 'default'
                    ? keys.teamConfigBase
                    : `${keys.teamConfigBase}_${projectId}`

                  if (overwrite || !loadFromStorage(key)) {
                    saveToStorage(key, config)
                    teamConfigCount++
                  }
                })
              }

              if (data.projectLevel.sprintCapacities) {
                Object.entries(data.projectLevel.sprintCapacities).forEach(([projectId, capacity]) => {
                  const key = projectId === 'default'
                    ? keys.sprintCapacityBase
                    : `${keys.sprintCapacityBase}_${projectId}`

                  if (overwrite || !loadFromStorage(key)) {
                    saveToStorage(key, capacity)
                    teamConfigCount++
                  }
                })
              }

              if (data.projectLevel.capacitySettings) {
                Object.entries(data.projectLevel.capacitySettings).forEach(([projectId, settings]) => {
                  const key = projectId === 'default'
                    ? keys.capacitySettingsBase
                    : `${keys.capacitySettingsBase}_${projectId}`

                  if (overwrite || !loadFromStorage(key)) {
                    saveToStorage(key, settings)
                    teamConfigCount++
                  }
                })
              }
            }

            // Restore pod-level configs
            if (data.podLevel) {
              if (data.podLevel.teamConfigs) {
                Object.entries(data.podLevel.teamConfigs).forEach(([podId, config]) => {
                  const key = `${keys.teamConfigBase}_pod_${podId}`

                  if (overwrite || !loadFromStorage(key)) {
                    saveToStorage(key, config)
                    teamConfigCount++
                  }
                })
              }

              if (data.podLevel.sprintCapacities) {
                Object.entries(data.podLevel.sprintCapacities).forEach(([podId, capacity]) => {
                  const key = `${keys.sprintCapacityBase}_pod_${podId}`

                  if (overwrite || !loadFromStorage(key)) {
                    saveToStorage(key, capacity)
                    teamConfigCount++
                  }
                })
              }

              if (data.podLevel.capacitySettings) {
                Object.entries(data.podLevel.capacitySettings).forEach(([podId, settings]) => {
                  const key = `${keys.capacitySettingsBase}_pod_${podId}`

                  if (overwrite || !loadFromStorage(key)) {
                    saveToStorage(key, settings)
                    teamConfigCount++
                  }
                })
              }
            }
          }
          // Handle old structure (backwards compatibility)
          else {
            if (data.teamConfigs) {
              Object.entries(data.teamConfigs).forEach(([projectId, config]) => {
                const key = projectId === 'default'
                  ? keys.teamConfigBase
                  : `${keys.teamConfigBase}_${projectId}`

                if (overwrite || !loadFromStorage(key)) {
                  saveToStorage(key, config)
                  teamConfigCount++
                }
              })
            }

            if (data.sprintCapacities) {
              Object.entries(data.sprintCapacities).forEach(([projectId, capacity]) => {
                const key = projectId === 'default'
                  ? keys.sprintCapacityBase
                  : `${keys.sprintCapacityBase}_${projectId}`

                if (overwrite || !loadFromStorage(key)) {
                  saveToStorage(key, capacity)
                  teamConfigCount++
                }
              })
            }

            if (data.capacitySettings) {
              Object.entries(data.capacitySettings).forEach(([projectId, settings]) => {
                const key = projectId === 'default'
                  ? keys.capacitySettingsBase
                  : `${keys.capacitySettingsBase}_${projectId}`

                if (overwrite || !loadFromStorage(key)) {
                  saveToStorage(key, settings)
                  teamConfigCount++
                }
              })
            }
          }

          if (teamConfigCount > 0) {
            result.restored.push(`teamConfiguration (${teamConfigCount} items)`)
          }
          break

        case 'absences':
          // Restore project and pod-level absences
          let absenceCount = 0

          // Handle new structure (projectLevel/podLevel)
          if (data.projectLevel || data.podLevel) {
            // Restore project-level absences
            if (data.projectLevel) {
              Object.entries(data.projectLevel).forEach(([projectId, absenceData]) => {
                const key = projectId === 'default'
                  ? keys.absencesBase
                  : `${keys.absencesBase}_${projectId}`

                if (overwrite || !loadFromStorage(key)) {
                  saveToStorage(key, absenceData)
                  absenceCount++
                }
              })
            }

            // Restore pod-level absences
            if (data.podLevel) {
              Object.entries(data.podLevel).forEach(([podId, absenceData]) => {
                const key = `${keys.absencesBase}_pod_${podId}`

                if (overwrite || !loadFromStorage(key)) {
                  saveToStorage(key, absenceData)
                  absenceCount++
                }
              })
            }
          }
          // Handle old structure (backwards compatibility)
          else {
            Object.entries(data).forEach(([projectId, absenceData]) => {
              const key = projectId === 'default'
                ? keys.absencesBase
                : `${keys.absencesBase}_${projectId}`

              if (overwrite || !loadFromStorage(key)) {
                saveToStorage(key, absenceData)
                absenceCount++
              }
            })
          }

          if (absenceCount > 0) {
            result.restored.push(`absences (${absenceCount} items)`)
          }
          break

        case 'stakeholderHub':
          if (data.stakeholders) {
            if (overwrite || !loadFromStorage(keys.stakeholders)) {
              saveToStorage(keys.stakeholders, data.stakeholders)
              result.restored.push('stakeholders')
            }
          }
          if (data.communicationHistory) {
            if (overwrite || !loadFromStorage(keys.communicationHistory)) {
              saveToStorage(keys.communicationHistory, data.communicationHistory)
              result.restored.push('communicationHistory')
            }
          }
          if (data.communicationTemplates) {
            if (overwrite || !loadFromStorage(keys.communicationTemplates)) {
              saveToStorage(keys.communicationTemplates, data.communicationTemplates)
              result.restored.push('communicationTemplates')
            }
          }
          if (data.decisions) {
            if (overwrite || !loadFromStorage(keys.stakeholderDecisions)) {
              saveToStorage(keys.stakeholderDecisions, data.decisions)
              result.restored.push('stakeholderDecisions')
            }
          }
          if (data.documents) {
            if (overwrite || !loadFromStorage(keys.documents)) {
              saveToStorage(keys.documents, data.documents)
              result.restored.push('documents')
            }
          }
          break

        case 'projectDecisions':
          // Restore project and pod-level decisions
          let decisionCount = 0

          // Handle new structure (projectLevel/podLevel)
          if (data.projectLevel || data.podLevel) {
            // Restore project-level decisions
            if (data.projectLevel) {
              Object.entries(data.projectLevel).forEach(([projectId, decisionData]) => {
                const key = projectId === 'default'
                  ? keys.projectDecisionsBase
                  : `${keys.projectDecisionsBase}_${projectId}`

                if (overwrite || !loadFromStorage(key)) {
                  saveToStorage(key, decisionData)
                  decisionCount++
                }
              })
            }

            // Restore pod-level decisions
            if (data.podLevel) {
              Object.entries(data.podLevel).forEach(([podId, decisionData]) => {
                const key = `${keys.projectDecisionsBase}_pod_${podId}`

                if (overwrite || !loadFromStorage(key)) {
                  saveToStorage(key, decisionData)
                  decisionCount++
                }
              })
            }
          }

          if (decisionCount > 0) {
            result.restored.push(`projectDecisions (${decisionCount} items)`)
          }
          break

        case 'healthScoreConfig':
          if (overwrite || !loadFromStorage(keys.healthScoreConfig)) {
            saveToStorage(keys.healthScoreConfig, data)
            result.restored.push('healthScoreConfig')
          }
          break

        case 'criteriaConfig':
          if (overwrite || !loadFromStorage(keys.criteriaConfig)) {
            saveToStorage(keys.criteriaConfig, data)
            result.restored.push('criteriaConfig')
          }
          break

        case 'dodTemplates':
          if (overwrite || !loadFromStorage(keys.dodTemplates)) {
            saveToStorage(keys.dodTemplates, data)
            result.restored.push('dodTemplates')
          }
          break

        case 'sprintGoals':
          if (overwrite || !loadFromStorage(keys.sprintGoals)) {
            saveToStorage(keys.sprintGoals, data)
            result.restored.push('sprintGoals')
          }
          break

        case 'retroActions':
          if (overwrite || !loadFromStorage(keys.retroActions)) {
            saveToStorage(keys.retroActions, data)
            result.restored.push('retroActions')
          }
          break

        case 'releases':
          if (overwrite || !loadFromStorage(keys.releases)) {
            saveToStorage(keys.releases, data)
            result.restored.push('releases')
          }
          break

        case 'featureToggles':
          if (overwrite || !loadFromStorage(keys.featureToggles)) {
            saveToStorage(keys.featureToggles, data)
            result.restored.push('featureToggles')
          }
          break

        case 'forecasts':
          // Restore project and pod-level forecasts
          let forecastCount = 0

          // Handle new structure (projectLevel/podLevel)
          if (data.projectLevel || data.podLevel) {
            // Restore project-level forecasts
            if (data.projectLevel) {
              Object.entries(data.projectLevel).forEach(([projectId, forecastData]) => {
                const key = projectId === 'default'
                  ? keys.forecastsBase
                  : `${keys.forecastsBase}_${projectId}`

                if (overwrite || !loadFromStorage(key)) {
                  saveToStorage(key, forecastData)
                  forecastCount++
                }
              })
            }

            // Restore pod-level forecasts
            if (data.podLevel) {
              Object.entries(data.podLevel).forEach(([podId, forecastData]) => {
                const key = `${keys.forecastsBase}_pod_${podId}`

                if (overwrite || !loadFromStorage(key)) {
                  saveToStorage(key, forecastData)
                  forecastCount++
                }
              })
            }
          }

          if (forecastCount > 0) {
            result.restored.push(`forecasts (${forecastCount} items)`)
          }
          break

        case 'backlogHealthHistory':
          if (overwrite || !loadFromStorage(keys.backlogHealthHistory)) {
            saveToStorage(keys.backlogHealthHistory, data)
            result.restored.push('backlogHealthHistory')
          }
          break

        case 'userRole':
          if (overwrite || !loadFromStorage(keys.userRole)) {
            saveToStorage(keys.userRole, data)
            result.restored.push('userRole')
          }
          break

        case 'viewPreference':
          if (overwrite || !loadFromStorage(keys.viewPreference)) {
            saveToStorage(keys.viewPreference, data)
            result.restored.push('viewPreference')
          }
          break

        case 'favoriteViews':
          if (overwrite || !loadFromStorage(keys.favoriteViews)) {
            saveToStorage(keys.favoriteViews, data)
            result.restored.push('favoriteViews')
          }
          break

        case 'velocityConfig':
          if (overwrite || !loadFromStorage(keys.velocityConfig)) {
            saveToStorage(keys.velocityConfig, data)
            result.restored.push('velocityConfig')
            // Trigger velocity config changed event so components update
            if (typeof window !== 'undefined') {
              window.dispatchEvent(new Event('velocityConfigChanged'))
            }
          }
          break

        case 'uiState':
          if (data.qualityShowOpenOnly !== null && data.qualityShowOpenOnly !== undefined) {
            saveToStorage(keys.qualityShowOpenOnly, data.qualityShowOpenOnly)
          }
          if (data.qualityLegendCollapsed !== null && data.qualityLegendCollapsed !== undefined) {
            saveToStorage(keys.qualityLegendCollapsed, data.qualityLegendCollapsed)
          }
          if (data.cycleTimeBottleneckCollapsed !== null && data.cycleTimeBottleneckCollapsed !== undefined) {
            saveToStorage(keys.cycleTimeBottleneckCollapsed, data.cycleTimeBottleneckCollapsed)
          }
          result.restored.push('uiState')
          break

        default:
          result.skipped.push(category + ' (unknown category)')
      }
    } catch (error) {
      console.error(`Failed to restore ${category}:`, error)
      result.failed.push(category)
      result.success = false
    }
  })

  return result
}

/**
 * Get backup statistics
 * @returns {Object} Statistics about current data
 */
export function getBackupStatistics() {
  const keys = getAllStorageKeys()
  const stats = {
    totalItems: 0,
    categories: [],
    estimatedSize: 0
  }

  Object.entries(keys).forEach(([category, key]) => {
    const data = loadFromStorage(key)
    if (data) {
      stats.totalItems++
      stats.categories.push(category)

      // Estimate size in bytes
      const jsonStr = JSON.stringify(data)
      stats.estimatedSize += jsonStr.length
    }
  })

  // Convert to KB
  stats.estimatedSizeKB = Math.round(stats.estimatedSize / 1024)

  return stats
}

/**
 * Clear all application data (use with caution!)
 * @param {boolean} confirm - Must be true to execute
 * @returns {boolean} Success
 */
export function clearAllData(confirm = false) {
  if (!confirm) {
    throw new Error('Must confirm clearAllData operation')
  }

  const keys = getAllStorageKeys()
  Object.values(keys).forEach(key => {
    localStorage.removeItem(key)
  })

  return true
}

/**
 * Compare two backups and show differences
 * @param {Object} backup1 - First backup
 * @param {Object} backup2 - Second backup
 * @returns {Object} Comparison result
 */
export function compareBackups(backup1, backup2) {
  const result = {
    differences: [],
    added: [],
    removed: [],
    modified: []
  }

  const categories1 = new Set(Object.keys(backup1.data))
  const categories2 = new Set(backup2.data)

  // Find added categories
  categories2.forEach(cat => {
    if (!categories1.has(cat)) {
      result.added.push(cat)
    }
  })

  // Find removed categories
  categories1.forEach(cat => {
    if (!categories2.has(cat)) {
      result.removed.push(cat)
    }
  })

  // Find modified categories (simple length check)
  categories1.forEach(cat => {
    if (categories2.has(cat)) {
      const json1 = JSON.stringify(backup1.data[cat])
      const json2 = JSON.stringify(backup2.data[cat])
      if (json1 !== json2) {
        result.modified.push(cat)
      }
    }
  })

  return result
}

```

---


## FILE: src/services/gitlabApi.js

```javascript
/**
 * GitLab API Service
 * Handles all communication with GitLab REST API
 */

/**
 * Validate and fetch project information
 * Helps diagnose 404 errors by checking if project exists and is accessible
 */
export async function validateProject(gitlabUrl, projectId, token) {
  const encodedProjectId = encodeURIComponent(projectId)
  const url = `${gitlabUrl}/api/v4/projects/${encodedProjectId}`

  console.log('Validating project access...')
  console.log('  URL:', url)

  const response = await fetch(url, {
    headers: { 'PRIVATE-TOKEN': token }
  })

  if (!response.ok) {
    const errorText = await response.text()
    console.error('Project validation failed:', errorText)

    if (response.status === 404) {
      throw new Error(`Project not found: "${projectId}"\n\nPossible issues:\n- Project ID might be incorrect\n- Use either numeric ID (e.g., "12345") or full path (e.g., "namespace/project-name")\n- Check if the token has access to this project\n- Verify the GitLab URL is correct`)
    } else if (response.status === 401) {
      throw new Error(`Authentication failed: Invalid or expired access token`)
    } else {
      throw new Error(`Project validation error: ${response.status} - ${response.statusText}`)
    }
  }

  const project = await response.json()
  console.log('‚úì Project validated:', project.name)
  console.log('  Full path:', project.path_with_namespace)
  console.log('  Numeric ID:', project.id)

  return project
}

/**
 * Fetch issues from a GitLab project with pagination
 */
export async function fetchIssues(gitlabUrl, projectId, token) {
  const encodedProjectId = encodeURIComponent(projectId)
  let allIssues = []
  let page = 1
  const perPage = 100

  console.log('Fetching issues with pagination...')
  console.log('  GitLab URL:', gitlabUrl)
  console.log('  Project ID:', projectId)
  console.log('  Encoded Project ID:', encodedProjectId)

  while (true) {
    const url = `${gitlabUrl}/api/v4/projects/${encodedProjectId}/issues?per_page=${perPage}&page=${page}&scope=all&with_iterations=true`
    console.log('  API Request URL:', url)

    const response = await fetch(url, {
      headers: { 'PRIVATE-TOKEN': token }
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('API Error Response:', errorText)
      throw new Error(`Issues API Error: ${response.status} - ${response.statusText}\nURL: ${url}\nProject ID: ${projectId}\nEncoded: ${encodedProjectId}\nResponse: ${errorText}`)
    }

    const issues = await response.json()

    if (issues.length === 0) {
      break // No more issues
    }

    allIssues = allIssues.concat(issues)
    console.log(`  Fetched page ${page}: ${issues.length} issues (total: ${allIssues.length})`)

    if (issues.length < perPage) {
      break // Last page (partial results)
    }

    page++
  }

  console.log(`‚úì Loaded ${allIssues.length} total issues from ${page} page(s)`)

  // Debug: Check iteration data on first few issues
  if (allIssues.length > 0) {
    console.log('=== ITERATION DEBUG ===')
    const sampleSize = Math.min(3, allIssues.length)
    for (let i = 0; i < sampleSize; i++) {
      const issue = allIssues[i]
      console.log(`Issue #${issue.iid} (${issue.title}):`)
      console.log('  - iteration field:', issue.iteration)
      console.log('  - labels:', issue.labels)
    }

    // Count how many issues have iteration data
    const withIteration = allIssues.filter(i => i.iteration).length
    const withIterationLabels = allIssues.filter(i =>
      i.labels && i.labels.some(l => l.toLowerCase().startsWith('sprint') || l.toLowerCase().startsWith('iteration'))
    ).length
    console.log(`Summary: ${withIteration} issues with iteration field, ${withIterationLabels} with iteration/sprint labels`)
    console.log('======================')
  }

  return allIssues
}

/**
 * Fetch milestones from a GitLab project with pagination
 */
export async function fetchMilestones(gitlabUrl, projectId, token) {
  const encodedProjectId = encodeURIComponent(projectId)
  let allMilestones = []
  let page = 1
  const perPage = 100

  console.log('Fetching milestones with pagination...')

  while (true) {
    const response = await fetch(
      `${gitlabUrl}/api/v4/projects/${encodedProjectId}/milestones?per_page=${perPage}&page=${page}`,
      { headers: { 'PRIVATE-TOKEN': token } }
    )

    if (!response.ok) {
      throw new Error(`Milestones API Error: ${response.status}`)
    }

    const milestones = await response.json()

    if (milestones.length === 0) {
      break // No more milestones
    }

    allMilestones = allMilestones.concat(milestones)
    console.log(`  Fetched page ${page}: ${milestones.length} milestones (total: ${allMilestones.length})`)

    if (milestones.length < perPage) {
      break // Last page (partial results)
    }

    page++
  }

  console.log(`‚úì Loaded ${allMilestones.length} total milestones from ${page} page(s)`)
  return allMilestones
}

/**
 * Update issue assignee
 * @param {string} gitlabUrl - GitLab instance URL
 * @param {string} projectId - Project ID or path
 * @param {number} issueIid - Issue IID
 * @param {number} assigneeId - New assignee's user ID
 * @param {string} token - GitLab API token
 * @returns {Promise<object>} Updated issue object
 */
export async function updateIssueAssignee(gitlabUrl, projectId, issueIid, assigneeId, token) {
  const encodedProjectId = encodeURIComponent(projectId)
  const url = `${gitlabUrl}/api/v4/projects/${encodedProjectId}/issues/${issueIid}`

  console.log(`Updating issue #${issueIid} assignee to user ${assigneeId}`)

  const response = await fetch(url, {
    method: 'PUT',
    headers: {
      'PRIVATE-TOKEN': token,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      assignee_id: assigneeId
    })
  })

  if (!response.ok) {
    const errorText = await response.text()
    console.error('Failed to update issue assignee:', errorText)

    if (response.status === 404) {
      throw new Error(`Issue #${issueIid} not found in project ${projectId}`)
    } else if (response.status === 401) {
      throw new Error('Unauthorized: Invalid or expired access token')
    } else if (response.status === 403) {
      throw new Error('Forbidden: You do not have permission to update this issue')
    } else {
      throw new Error(`Failed to update assignee: ${response.status} - ${errorText}`)
    }
  }

  const updatedIssue = await response.json()
  console.log(`‚úì Successfully updated issue #${issueIid} assignee`)
  return updatedIssue
}

/**
 * Batch update multiple issues with new assignee
 * @param {string} gitlabUrl - GitLab instance URL
 * @param {string} projectId - Project ID or path
 * @param {array} issues - Array of issues to update
 * @param {number} assigneeId - New assignee's user ID
 * @param {string} token - GitLab API token
 * @param {function} onProgress - Progress callback (optional)
 * @returns {Promise<object>} Results object with success/failed arrays
 */
export async function batchUpdateIssueAssignees(gitlabUrl, projectId, issues, assigneeId, token, onProgress = null) {
  const results = {
    successful: [],
    failed: []
  }

  console.log(`Starting batch update for ${issues.length} issues`)

  for (let i = 0; i < issues.length; i++) {
    const issue = issues[i]

    if (onProgress) {
      onProgress({
        current: i + 1,
        total: issues.length,
        issue: issue
      })
    }

    try {
      const updated = await updateIssueAssignee(gitlabUrl, projectId, issue.iid, assigneeId, token)
      results.successful.push({
        issue: issue,
        updated: updated
      })
    } catch (error) {
      console.error(`Failed to update issue #${issue.iid}:`, error.message)
      results.failed.push({
        issue: issue,
        error: error.message
      })
    }

    // Add small delay to avoid rate limiting
    if (i < issues.length - 1) {
      await new Promise(resolve => setTimeout(resolve, 200))
    }
  }

  console.log(`Batch update completed: ${results.successful.length} successful, ${results.failed.length} failed`)
  return results
}

/**
 * Fetch epics from a GitLab group (Premium/Ultimate only) with pagination
 */
export async function fetchEpics(gitlabUrl, groupPath, token) {
  if (!groupPath) {
    return [] // No group path configured
  }

  const encodedGroupPath = encodeURIComponent(groupPath)
  let allEpics = []
  let page = 1
  const perPage = 100

  console.log('Fetching epics with pagination...')
  console.log('  GitLab URL:', gitlabUrl)
  console.log('  Group Path:', groupPath)
  console.log('  Encoded Group Path:', encodedGroupPath)

  try {
    while (true) {
      const url = `${gitlabUrl}/api/v4/groups/${encodedGroupPath}/epics?per_page=${perPage}&page=${page}`
      console.log('  Epic API Request URL:', url)

      const response = await fetch(url, { headers: { 'PRIVATE-TOKEN': token } })

      console.log(`  Epic API Response Status: ${response.status}`)

      if (response.status === 404) {
        console.warn('Epics not available (requires Premium/Ultimate)')
        return []
      }

      if (!response.ok) {
        const errorText = await response.text()
        console.error('Epic API Error Response:', errorText)
        throw new Error(`Epics API Error: ${response.status} - ${errorText}`)
      }

      const epics = await response.json()
      console.log(`  Epics returned on page ${page}:`, epics.length)

      if (epics.length === 0) {
        break // No more epics
      }

      allEpics = allEpics.concat(epics)
      console.log(`  Fetched page ${page}: ${epics.length} epics (total: ${allEpics.length})`)

      if (epics.length < perPage) {
        break // Last page (partial results)
      }

      page++
    }

    console.log(`‚úì Loaded ${allEpics.length} total epics from ${page} page(s)`)
    return allEpics
  } catch (error) {
    console.error('Epic fetch failed:', error)
    return []
  }
}

/**
 * Fetch issues for a specific epic
 */
export async function fetchEpicIssues(gitlabUrl, groupPath, epicId, token) {
  const encodedGroupPath = encodeURIComponent(groupPath)

  const response = await fetch(
    `${gitlabUrl}/api/v4/groups/${encodedGroupPath}/epics/${epicId}/issues`,
    { headers: { 'PRIVATE-TOKEN': token } }
  )

  if (!response.ok) {
    throw new Error(`Epic Issues API Error: ${response.status}`)
  }

  return response.json()
}

/**
 * Check if Resource State Events API is available (Premium/Ultimate feature)
 */
export async function checkPremiumFeatures(gitlabUrl, projectId, token) {
  const encodedProjectId = encodeURIComponent(projectId)

  try {
    // Try to fetch resource state events for the project
    const response = await fetch(
      `${gitlabUrl}/api/v4/projects/${encodedProjectId}/issues?per_page=1`,
      { headers: { 'PRIVATE-TOKEN': token } }
    )

    if (!response.ok) {
      return { hasLabelHistory: false, hasResourceEvents: false }
    }

    const issues = await response.json()
    if (issues.length === 0) {
      return { hasLabelHistory: false, hasResourceEvents: false }
    }

    // Try to fetch resource state events for first issue
    const testIssueIid = issues[0].iid
    const eventsResponse = await fetch(
      `${gitlabUrl}/api/v4/projects/${encodedProjectId}/issues/${testIssueIid}/resource_state_events`,
      { headers: { 'PRIVATE-TOKEN': token } }
    )

    // Try to fetch resource label events (check both independently)
    const labelEventsResponse = await fetch(
      `${gitlabUrl}/api/v4/projects/${encodedProjectId}/issues/${testIssueIid}/resource_label_events`,
      { headers: { 'PRIVATE-TOKEN': token } }
    )

    const hasLabelHistory = labelEventsResponse.ok
    const hasResourceEvents = eventsResponse.ok

    console.log(`GitLab Premium Features for project ${projectId}:`, {
      hasLabelHistory,
      hasResourceEvents
    })

    return { hasLabelHistory, hasResourceEvents, projectId }
  } catch (error) {
    console.error(`Premium feature check failed for project ${projectId}:`, error)
    return { hasLabelHistory: false, hasResourceEvents: false, projectId }
  }
}

/**
 * Check Premium features for multiple projects
 * Used in Pods/multi-project mode to determine which projects have Premium
 */
export async function checkPremiumFeaturesForProjects(gitlabUrl, projectIds, token) {
  const results = await Promise.all(
    projectIds.map(projectId => checkPremiumFeatures(gitlabUrl, projectId, token))
  )

  // Build a map of projectId -> features
  const featuresMap = {}
  results.forEach(result => {
    featuresMap[result.projectId] = {
      hasLabelHistory: result.hasLabelHistory,
      hasResourceEvents: result.hasResourceEvents
    }
  })

  // Determine overall status
  const anyPremium = results.some(r => r.hasLabelHistory || r.hasResourceEvents)
  const allPremium = results.every(r => r.hasLabelHistory && r.hasResourceEvents)
  const premiumCount = results.filter(r => r.hasLabelHistory || r.hasResourceEvents).length

  console.log('Multi-project Premium check:', {
    totalProjects: projectIds.length,
    premiumCount,
    allPremium,
    anyPremium
  })

  return {
    featuresMap,
    anyPremium,
    allPremium,
    premiumCount,
    totalProjects: projectIds.length
  }
}

/**
 * Fetch resource label events for an issue (Premium/Ultimate only)
 * Returns label add/remove history with timestamps
 */
export async function fetchIssueLabelHistory(gitlabUrl, projectId, issueIid, token) {
  const encodedProjectId = encodeURIComponent(projectId)

  try {
    const response = await fetch(
      `${gitlabUrl}/api/v4/projects/${encodedProjectId}/issues/${issueIid}/resource_label_events`,
      { headers: { 'PRIVATE-TOKEN': token } }
    )

    if (!response.ok) {
      return null // Not available
    }

    return response.json()
  } catch (error) {
    console.error(`Failed to fetch label history for issue ${issueIid}:`, error)
    return null
  }
}

/**
 * Fetch resource state events for an issue (Premium/Ultimate only)
 * Returns state change history (opened/closed) with timestamps
 */
export async function fetchIssueStateHistory(gitlabUrl, projectId, issueIid, token) {
  const encodedProjectId = encodeURIComponent(projectId)

  try {
    const response = await fetch(
      `${gitlabUrl}/api/v4/projects/${encodedProjectId}/issues/${issueIid}/resource_state_events`,
      { headers: { 'PRIVATE-TOKEN': token } }
    )

    if (!response.ok) {
      return null // Not available
    }

    return response.json()
  } catch (error) {
    console.error(`Failed to fetch state history for issue ${issueIid}:`, error)
    return null
  }
}

/**
 * Validate and fetch group information
 */
export async function validateGroup(gitlabUrl, groupPath, token) {
  const encodedGroupPath = encodeURIComponent(groupPath)
  const url = `${gitlabUrl}/api/v4/groups/${encodedGroupPath}`

  console.log('Validating group access...')
  console.log('  URL:', url)

  const response = await fetch(url, {
    headers: { 'PRIVATE-TOKEN': token }
  })

  if (!response.ok) {
    const errorText = await response.text()
    console.error('Group validation failed:', errorText)

    if (response.status === 404) {
      throw new Error(`Group not found: "${groupPath}"\n\nPossible issues:\n- Group ID/path might be incorrect\n- Use either numeric ID (e.g., "12345") or full path (e.g., "my-group" or "parent/child-group")\n- Check if the token has access to this group\n- Verify the GitLab URL is correct`)
    } else if (response.status === 401) {
      throw new Error(`Authentication failed: Invalid or expired access token`)
    } else {
      throw new Error(`Group validation error: ${response.status} - ${response.statusText}`)
    }
  }

  const group = await response.json()
  console.log('‚úì Group validated:', group.name)
  console.log('  Full path:', group.full_path)
  console.log('  Numeric ID:', group.id)

  return group
}

/**
 * Fetch all projects under a group (including subgroups recursively)
 */
export async function fetchGroupProjects(gitlabUrl, groupPath, token) {
  const encodedGroupPath = encodeURIComponent(groupPath)
  let allProjects = []
  let page = 1
  const perPage = 100

  console.log('Fetching all projects in group (including subgroups)...')
  console.log('  Group Path:', groupPath)

  while (true) {
    // include_subgroups=true fetches all projects from subgroups recursively
    const url = `${gitlabUrl}/api/v4/groups/${encodedGroupPath}/projects?per_page=${perPage}&page=${page}&include_subgroups=true&archived=false`

    const response = await fetch(url, {
      headers: { 'PRIVATE-TOKEN': token }
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('Group Projects API Error:', errorText)
      throw new Error(`Group Projects API Error: ${response.status} - ${errorText}`)
    }

    const projects = await response.json()

    if (projects.length === 0) {
      break
    }

    allProjects = allProjects.concat(projects)
    console.log(`  Fetched page ${page}: ${projects.length} projects (total: ${allProjects.length})`)

    if (projects.length < perPage) {
      break
    }

    page++
  }

  console.log(`‚úì Found ${allProjects.length} projects in group "${groupPath}"`)

  // Log project summary
  if (allProjects.length > 0) {
    console.log('  Projects:')
    allProjects.forEach(p => {
      console.log(`    - ${p.path_with_namespace} (ID: ${p.id})`)
    })
  }

  return allProjects
}

/**
 * Fetch issues from multiple projects in parallel
 */
export async function fetchIssuesFromProjects(gitlabUrl, projects, token, onProgress = null) {
  console.log(`Fetching issues from ${projects.length} projects...`)

  const batchSize = 5 // Process 5 projects at a time to avoid overwhelming the API
  let allIssues = []
  let processed = 0

  for (let i = 0; i < projects.length; i += batchSize) {
    const batch = projects.slice(i, i + batchSize)

    const batchResults = await Promise.all(
      batch.map(async (project) => {
        try {
          const issues = await fetchIssues(gitlabUrl, project.id, token)
          return { projectId: project.id, projectPath: project.path_with_namespace, issues }
        } catch (error) {
          console.warn(`Failed to fetch issues from project ${project.path_with_namespace}:`, error)
          return { projectId: project.id, projectPath: project.path_with_namespace, issues: [] }
        }
      })
    )

    batchResults.forEach(({ projectPath, issues }) => {
      if (issues.length > 0) {
        console.log(`  ‚úì ${projectPath}: ${issues.length} issues`)
      }
      allIssues = allIssues.concat(issues)
    })

    processed += batch.length
    if (onProgress) {
      onProgress(processed, projects.length)
    }
  }

  console.log(`‚úì Loaded ${allIssues.length} total issues from ${projects.length} projects`)
  return allIssues
}

/**
 * Fetch milestones from multiple projects in parallel
 */
export async function fetchMilestonesFromProjects(gitlabUrl, projects, token) {
  console.log(`Fetching milestones from ${projects.length} projects...`)

  const batchSize = 5
  let allMilestones = []

  for (let i = 0; i < projects.length; i += batchSize) {
    const batch = projects.slice(i, i + batchSize)

    const batchResults = await Promise.all(
      batch.map(async (project) => {
        try {
          const milestones = await fetchMilestones(gitlabUrl, project.id, token)
          return { projectPath: project.path_with_namespace, milestones }
        } catch (error) {
          console.warn(`Failed to fetch milestones from project ${project.path_with_namespace}:`, error)
          return { projectPath: project.path_with_namespace, milestones: [] }
        }
      })
    )

    batchResults.forEach(({ milestones }) => {
      allMilestones = allMilestones.concat(milestones)
    })
  }

  // Remove duplicate milestones (same title and dates)
  const uniqueMilestones = Array.from(
    new Map(allMilestones.map(m => [m.id, m])).values()
  )

  console.log(`‚úì Loaded ${uniqueMilestones.length} unique milestones from ${projects.length} projects`)
  return uniqueMilestones
}

/**
 * Filter data to only include items from 2025 onwards
 */
function filterByYear2025(data, dateFields) {
  const year2025Start = new Date('2025-01-01').getTime()

  return data.filter(item => {
    // Check if any of the date fields is >= 2025
    return dateFields.some(field => {
      const dateValue = item[field]
      if (!dateValue) return false

      const itemDate = new Date(dateValue).getTime()
      return itemDate >= year2025Start
    })
  })
}

/**
 * Fetch all data needed for the dashboard
 */
export async function fetchAllData(config) {
  const { gitlabUrl, projectId, groupPath, groupPaths, token, filter2025, mode } = config

  console.log('=== Starting GitLab Data Fetch ===')
  console.log('Full config object:', config)
  console.log('Mode:', mode || 'project (default)')

  let allIssues, allMilestones, projects = []
  const isSingleProjectMode = mode !== 'group'

  // GROUP MODE: Fetch all projects from group, then fetch all issues
  if (mode === 'group') {
    if (!groupPath && (!groupPaths || groupPaths.length === 0)) {
      throw new Error('Group mode requires groupPath or groupPaths to be configured')
    }

    // Use the first groupPath for fetching projects
    const primaryGroupPath = groupPaths && groupPaths.length > 0 ? groupPaths[0] : groupPath

    // Validate group access
    await validateGroup(gitlabUrl, primaryGroupPath, token)

    // Fetch all projects in the group
    projects = await fetchGroupProjects(gitlabUrl, primaryGroupPath, token)

    console.log(`\nüìä GROUP MODE: Fetching data from ${projects.length} projects in "${primaryGroupPath}"\n`)

    // Fetch issues and milestones from all projects
    const [issuesResult, milestonesResult] = await Promise.all([
      fetchIssuesFromProjects(gitlabUrl, projects, token),
      fetchMilestonesFromProjects(gitlabUrl, projects, token)
    ])

    allIssues = issuesResult
    allMilestones = milestonesResult
  }
  // PROJECT MODE: Fetch from single project (existing behavior)
  else {
    console.log('Config values:', {
      gitlabUrl,
      projectId,
      groupPath: groupPath || '(none)',
      groupPathType: typeof groupPath,
      groupPathLength: groupPath?.length
    })

    // Validate project access
    await validateProject(gitlabUrl, projectId, token)

    console.log(`\nüìä PROJECT MODE: Fetching data from single project "${projectId}"\n`)

    // Fetch issues and milestones from single project
    const [issuesResult, milestonesResult] = await Promise.all([
      fetchIssues(gitlabUrl, projectId, token),
      fetchMilestones(gitlabUrl, projectId, token)
    ])

    allIssues = issuesResult
    allMilestones = milestonesResult
  }

  // Fetch epics from all configured groups
  const groupPathsToFetch = groupPaths && Array.isArray(groupPaths) && groupPaths.length > 0
    ? groupPaths
    : (groupPath ? [groupPath] : [])

  const epicResults = await Promise.all(
    groupPathsToFetch.map(path => fetchEpics(gitlabUrl, path, token))
  )

  // Merge epics from all groups and remove duplicates
  const allEpics = epicResults.flat()
  const uniqueEpics = Array.from(
    new Map(allEpics.map(epic => [epic.id, epic])).values()
  )

  // Apply 2025 filter if enabled (default: true for backwards compatibility)
  const shouldFilter = filter2025 !== false

  // Filter issues: show if created_at, updated_at, or due_date >= 2025
  const issues = shouldFilter
    ? filterByYear2025(allIssues, ['created_at', 'updated_at', 'due_date'])
    : allIssues

  // Filter milestones: show if start_date, due_date, or created_at >= 2025
  const milestones = shouldFilter
    ? filterByYear2025(allMilestones, ['start_date', 'due_date', 'created_at'])
    : allMilestones

  // Filter epics: show if start_date, end_date, or created_at >= 2025
  const epics = shouldFilter
    ? filterByYear2025(uniqueEpics, ['start_date', 'end_date', 'created_at'])
    : uniqueEpics

  console.log(`Filtered data: ${allIssues.length} ‚Üí ${issues.length} issues, ${allMilestones.length} ‚Üí ${milestones.length} milestones, ${uniqueEpics.length} ‚Üí ${epics.length} epics ${shouldFilter ? '(>= 2025)' : '(no filter)'}`)

  if (mode === 'group') {
    console.log(`  Aggregated from ${projects.length} projects in group`)
  }

  // Import cross-project linking functions
  const {
    linkCrossProjectIssues,
    enhanceEpicsWithCrossProjectData,
    buildEpicHierarchy,
    findOrphanedIssues
  } = await import('./crossProjectLinkingService.js')

  // Build cross-project relationships with available data
  const linkingData = linkCrossProjectIssues(issues, epics)

  // Add metadata about mode
  linkingData.singleProjectMode = isSingleProjectMode
  linkingData.selectedProjectId = isSingleProjectMode ? projectId : null
  linkingData.limitedView = isSingleProjectMode // Only showing issues from selected project in project mode
  linkingData.mode = mode || 'project'
  linkingData.projectCount = mode === 'group' ? projects.length : 1

  // Build epic hierarchy
  const { rootEpics, epicMap } = buildEpicHierarchy(epics)

  // Enhance epics with cross-project metadata
  const enhancedEpics = enhanceEpicsWithCrossProjectData(epics, linkingData)

  // Find orphaned issues that might need epic assignment
  const orphanedIssues = findOrphanedIssues(issues)

  // Enrich epics with their issues from issue data (workaround for 403 on Epic Issues API)
  const epicsWithIssues = enhancedEpics.map((epic) => {
    // Find all issues that belong to this epic
    const epicIssues = issues.filter(issue =>
      issue.epic && issue.epic.id === epic.id
    )

    return { ...epic, issues: epicIssues }
  })

  console.log(`‚úì Loaded ${epics.length} epics with ${epicsWithIssues.reduce((sum, e) => sum + e.issues.length, 0)} total issues`)
  console.log(`‚úì Cross-project statistics:`, linkingData.statistics)
  if (orphanedIssues.length > 0) {
    console.log(`  Found ${orphanedIssues.length} orphaned issues that might need epic assignment`)
  }

  return {
    issues,
    milestones,
    epics: epicsWithIssues,
    projects, // Include projects list for group mode
    crossProjectData: {
      ...linkingData,
      epicHierarchy: { rootEpics, epicMap },
      orphanedIssues
    }
  }
}

```

---


## FILE: src/hooks/useGitLabData.js

```javascript
/**
 * Custom hook for fetching and managing GitLab data
 * Handles loading states, errors, and data caching
 * Supports both single-project and cross-project aggregation
 */

import { useState, useEffect, useCallback } from 'react'
import { fetchAllData } from '../services/gitlabApi'
import { loadConfig, isConfigured, getActiveProjectId, getAllProjects, getActiveGroupId, getActiveGroup } from '../services/storageService'
import { getProjectGroup, getProjectsForGroup } from '../services/projectGroupService'

export default function useGitLabData() {
  const [data, setData] = useState({
    issues: [],
    milestones: [],
    epics: [],
    crossProjectData: null
  })
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const [config, setConfig] = useState(null)

  // Load configuration
  useEffect(() => {
    const savedConfig = loadConfig()
    console.log('useGitLabData: Loading config from storage:', savedConfig)
    console.log('  groupPath value:', savedConfig.groupPath)
    console.log('  groupPath type:', typeof savedConfig.groupPath)
    console.log('  groupPath length:', savedConfig.groupPath?.length)
    setConfig(savedConfig)
  }, [])

  // Fetch data from GitLab (single project, project group, or cross-project aggregation)
  const fetchData = useCallback(async () => {
    const activeProjectId = getActiveProjectId()
    const activeGroupId = getActiveGroupId()

    // Check if POD mode is active (GitLab Group/Pod)
    if (activeGroupId) {
      console.log('useGitLabData: Pod mode detected, activeGroupId:', activeGroupId)
      const activePod = getActiveGroup()

      if (!activePod) {
        console.warn('useGitLabData: Pod not found:', activeGroupId)
        return
      }

      setLoading(true)
      setError(null)

      try {
        console.log(`useGitLabData: Fetching data for pod "${activePod.name}"...`)
        console.log('  Pod config:', activePod)

        const mainConfig = loadConfig()
        const podConfig = {
          gitlabUrl: activePod.gitlabUrl,
          token: mainConfig.token, // Use centralized token
          groupPath: activePod.groupPath,
          mode: 'group',
          filter2025: mainConfig.filter2025
        }

        const result = await fetchAllData(podConfig)

        console.log(`useGitLabData: Pod data fetch complete:`)
        console.log(`  Pod: ${activePod.name}`)
        console.log(`  Total issues: ${result.issues.length}`)
        console.log(`  Total milestones: ${result.milestones.length}`)
        console.log(`  Total epics: ${result.epics.length}`)

        setData(result)
      } catch (err) {
        console.error('Pod data fetch failed:', err)
        setError(err.message)
      } finally {
        setLoading(false)
      }
      return
    }

    // Check if project group mode is active
    if (activeProjectId?.startsWith('group:')) {
      console.log('useGitLabData: Project group mode detected')
      const groupId = activeProjectId.replace('group:', '')
      const group = getProjectGroup(groupId)

      if (!group) {
        console.warn('useGitLabData: Project group not found:', groupId)
        return
      }

      const allProjects = getAllProjects()
      const groupProjects = getProjectsForGroup(groupId, allProjects)

      if (groupProjects.length === 0) {
        console.warn('useGitLabData: No projects in group:', group.name)
        return
      }

      setLoading(true)
      setError(null)

      try {
        console.log(`useGitLabData: Fetching data for project group "${group.name}" (${groupProjects.length} projects)...`)

        // Fetch data from all projects in the group
        const mainConfig = loadConfig()
        const projectDataPromises = groupProjects.map(async (project) => {
          try {
            console.log(`  Fetching project: ${project.name}`)
            const projectConfig = {
              gitlabUrl: project.gitlabUrl,
              token: mainConfig.token, // Use centralized token
              projectId: project.projectId,
              groupPath: project.groupPath,
              groupPaths: project.groupPaths, // Support multiple group paths per project
              filter2025: loadConfig().filter2025
            }
            const data = await fetchAllData(projectConfig)

            // Tag each item with its source project
            return {
              projectId: project.id,
              projectName: project.name,
              issues: data.issues.map(issue => ({ ...issue, _projectId: project.id, _projectName: project.name })),
              milestones: data.milestones.map(ms => ({ ...ms, _projectId: project.id, _projectName: project.name })),
              epics: data.epics.map(epic => ({ ...epic, _projectId: project.id, _projectName: project.name }))
            }
          } catch (err) {
            console.error(`  Failed to fetch project ${project.name}:`, err)
            return {
              projectId: project.id,
              projectName: project.name,
              issues: [],
              milestones: [],
              epics: [],
              error: err.message
            }
          }
        })

        const projectsData = await Promise.all(projectDataPromises)

        // If the group has shared group paths, fetch additional epics
        let sharedEpics = []
        if (group.sharedGroupPaths && group.sharedGroupPaths.length > 0) {
          console.log(`  Fetching epics from ${group.sharedGroupPaths.length} shared group paths...`)

          // Use the first project's config as base for shared group fetches
          const baseProject = groupProjects[0]
          const sharedEpicPromises = group.sharedGroupPaths.map(async (groupPath) => {
            try {
              console.log(`    Fetching shared group: ${groupPath}`)
              const sharedConfig = {
                gitlabUrl: baseProject.gitlabUrl,
                token: baseProject.token,
                projectId: baseProject.projectId, // Still need a project for base URL
                groupPaths: [groupPath],
                filter2025: loadConfig().filter2025
              }
              const data = await fetchAllData(sharedConfig)
              return data.epics.map(epic => ({ ...epic, _sharedSource: groupPath }))
            } catch (err) {
              console.error(`    Failed to fetch shared group ${groupPath}:`, err)
              return []
            }
          })

          const sharedEpicsResults = await Promise.all(sharedEpicPromises)
          sharedEpics = sharedEpicsResults.flat()
          console.log(`  Found ${sharedEpics.length} epics from shared groups`)
        }

        // Import cross-project linking functions
        const { linkCrossProjectIssues, buildEpicHierarchy } = await import('../services/crossProjectLinkingService.js')

        // Aggregate all data
        const allIssues = projectsData.flatMap(p => p.issues)
        const allEpics = [...projectsData.flatMap(p => p.epics), ...sharedEpics]
        const allMilestones = projectsData.flatMap(p => p.milestones)

        // Deduplicate epics (in case of overlap between project groups and shared groups)
        const uniqueEpicsMap = new Map()
        allEpics.forEach(epic => {
          if (!uniqueEpicsMap.has(epic.id)) {
            uniqueEpicsMap.set(epic.id, epic)
          }
        })
        const uniqueEpics = Array.from(uniqueEpicsMap.values())

        // Build cross-project relationships
        const crossProjectData = linkCrossProjectIssues(allIssues, uniqueEpics)
        const epicHierarchy = buildEpicHierarchy(uniqueEpics)

        // Mark as project group mode
        crossProjectData.singleProjectMode = false
        crossProjectData.limitedView = false
        crossProjectData.projectGroupMode = true
        crossProjectData.projectGroupName = group.name
        crossProjectData.projectCount = groupProjects.length

        const aggregatedData = {
          issues: allIssues,
          milestones: allMilestones,
          epics: uniqueEpics,
          crossProjectData: {
            ...crossProjectData,
            epicHierarchy
          }
        }

        console.log(`useGitLabData: Project group aggregation complete:`)
        console.log(`  Group: ${group.name}`)
        console.log(`  Total issues: ${aggregatedData.issues.length}`)
        console.log(`  Total milestones: ${aggregatedData.milestones.length}`)
        console.log(`  Total epics: ${aggregatedData.epics.length}`)

        // Log any project failures
        const failedProjects = projectsData.filter(p => p.error)
        if (failedProjects.length > 0) {
          console.warn(`  Failed projects: ${failedProjects.map(p => p.projectName).join(', ')}`)
        }

        setData(aggregatedData)
      } catch (err) {
        console.error('Project group data fetch failed:', err)
        setError(err.message)
      } finally {
        setLoading(false)
      }
    }
    // Check if cross-project mode is active
    else if (activeProjectId === 'cross-project') {
      console.log('useGitLabData: Cross-project mode detected')
      const allProjects = getAllProjects()

      if (allProjects.length === 0) {
        console.warn('useGitLabData: No projects configured for cross-project view')
        return
      }

      setLoading(true)
      setError(null)

      try {
        console.log(`useGitLabData: Fetching data from ${allProjects.length} projects...`)

        // Fetch data from all projects in parallel
        const mainConfig = loadConfig()
        const projectDataPromises = allProjects.map(async (project) => {
          try {
            console.log(`  Fetching project: ${project.name}`)
            const projectConfig = {
              gitlabUrl: project.gitlabUrl,
              token: mainConfig.token, // Use centralized token
              projectId: project.projectId,
              groupPath: project.groupPath,
              groupPaths: project.groupPaths, // Support multiple group paths
              filter2025: mainConfig.filter2025 // Use global filter setting
            }
            const data = await fetchAllData(projectConfig)

            // Tag each item with its source project
            return {
              projectId: project.id,
              projectName: project.name,
              issues: data.issues.map(issue => ({ ...issue, _projectId: project.id, _projectName: project.name })),
              milestones: data.milestones.map(ms => ({ ...ms, _projectId: project.id, _projectName: project.name })),
              epics: data.epics.map(epic => ({ ...epic, _projectId: project.id, _projectName: project.name }))
            }
          } catch (err) {
            console.error(`  Failed to fetch project ${project.name}:`, err)
            return {
              projectId: project.id,
              projectName: project.name,
              issues: [],
              milestones: [],
              epics: [],
              error: err.message
            }
          }
        })

        const projectsData = await Promise.all(projectDataPromises)

        // Import cross-project linking functions
        const { linkCrossProjectIssues, buildEpicHierarchy } = await import('../services/crossProjectLinkingService.js')

        // Aggregate all data
        const allIssues = projectsData.flatMap(p => p.issues)
        const allEpics = projectsData.flatMap(p => p.epics)
        const allMilestones = projectsData.flatMap(p => p.milestones)

        // Build cross-project relationships
        const crossProjectData = linkCrossProjectIssues(allIssues, allEpics)
        const epicHierarchy = buildEpicHierarchy(allEpics)

        // Mark as full cross-project mode (all projects loaded)
        crossProjectData.singleProjectMode = false
        crossProjectData.limitedView = false
        crossProjectData.projectCount = allProjects.length

        const aggregatedData = {
          issues: allIssues,
          milestones: allMilestones,
          epics: allEpics,
          crossProjectData: {
            ...crossProjectData,
            epicHierarchy
          }
        }

        console.log(`useGitLabData: Cross-project aggregation complete:`)
        console.log(`  Total issues: ${aggregatedData.issues.length}`)
        console.log(`  Total milestones: ${aggregatedData.milestones.length}`)
        console.log(`  Total epics: ${aggregatedData.epics.length}`)

        // Log any project failures
        const failedProjects = projectsData.filter(p => p.error)
        if (failedProjects.length > 0) {
          console.warn(`  Failed projects: ${failedProjects.map(p => p.projectName).join(', ')}`)
        }

        setData(aggregatedData)
      } catch (err) {
        console.error('Cross-project data fetch failed:', err)
        setError(err.message)
      } finally {
        setLoading(false)
      }
    } else {
      // Single project mode
      if (!config || !isConfigured()) {
        return
      }

      setLoading(true)
      setError(null)

      try {
        const result = await fetchAllData(config)
        setData(result)
      } catch (err) {
        console.error('GitLab data fetch failed:', err)
        setError(err.message)
      } finally {
        setLoading(false)
      }
    }
  }, [config])

  // Auto-fetch on config change or when entering cross-project/group/pod mode
  useEffect(() => {
    console.log('üîÑ useGitLabData: useEffect triggered (config changed)')
    console.log('  Current config:', config)

    const activeProjectId = getActiveProjectId()
    const activeGroupId = getActiveGroupId()
    const configured = isConfigured()

    console.log('  activeProjectId:', activeProjectId)
    console.log('  activeGroupId:', activeGroupId)
    console.log('  isConfigured():', configured)

    // Fetch if in pod mode OR cross-project mode OR project group mode OR if single project is configured
    if (activeGroupId || activeProjectId === 'cross-project' || activeProjectId?.startsWith('group:') || (config && configured)) {
      console.log('‚úÖ Conditions met, calling fetchData()')
      fetchData()
    } else {
      console.log('‚ùå Conditions NOT met, skipping fetchData()')
      console.log('  Reasons:')
      console.log('    - activeGroupId:', !!activeGroupId)
      console.log('    - cross-project mode:', activeProjectId === 'cross-project')
      console.log('    - group mode:', activeProjectId?.startsWith('group:'))
      console.log('    - config exists:', !!config)
      console.log('    - isConfigured:', configured)
    }
  }, [config, fetchData])

  // Refresh function for manual reloading
  const refresh = useCallback(() => {
    console.log('üîÑ REFRESH CALLED')
    console.log('  Current config state:', config)

    // Reload config from storage before fetching (important for portfolio switching)
    const freshConfig = loadConfig()
    console.log('  Fresh config from localStorage:', freshConfig)
    console.log('  Fresh groupPath:', freshConfig.groupPath)
    console.log('  Fresh projectId:', freshConfig.projectId)
    console.log('  Fresh token exists:', !!freshConfig.token)

    setConfig(freshConfig)
    console.log('  Config state updated, useEffect should trigger...')
    // fetchData will be called automatically via the useEffect when config changes
  }, [])

  return {
    issues: data.issues,
    milestones: data.milestones,
    epics: data.epics,
    crossProjectData: data.crossProjectData,
    loading,
    error,
    refresh,
    isConfigured: isConfigured()
  }
}

```

---


## FILE: src/components/CommunicationsTab.jsx

```javascript
import React, { useState, useMemo } from 'react'
import {
  COMMUNICATION_TYPES,
  logCommunication,
  saveDecision,
  getCommunicationType
} from '../services/stakeholderService'

/**
 * Unified Communications Tab
 * Combines all communication types including decisions
 * Timeline view as default with creation mode
 */
export default function CommunicationsTab({
  history,
  stakeholders,
  onHistoryUpdate,
  onStakeholderSelect
}) {
  const [viewMode, setViewMode] = useState('timeline') // 'timeline' or 'create'
  const [timelineView, setTimelineView] = useState('list') // 'list' or 'gantt'
  const [filterType, setFilterType] = useState('all')
  const [filterDateRange, setFilterDateRange] = useState('all') // all, today, week, month
  const [searchQuery, setSearchQuery] = useState('')
  const [showQuickCreate, setShowQuickCreate] = useState(false)
  const [selectedItem, setSelectedItem] = useState(null)
  const [ganttRange, setGanttRange] = useState({ start: null, end: null })

  // Gantt specific filters - initialize with the year that has the most recent data
  const [ganttYear, setGanttYear] = useState(() => {
    // If we have history, use the year of the most recent item
    if (history && history.length > 0) {
      const mostRecent = history[0] // Assuming history is sorted by date descending
      const date = new Date(mostRecent.sentAt || mostRecent.createdAt || mostRecent.decisionDate)
      return date.getFullYear()
    }
    return new Date().getFullYear()
  })
  const [ganttQuarters, setGanttQuarters] = useState([1, 2, 3, 4]) // All quarters by default

  // Form state - simplified with progressive disclosure
  const [communicationForm, setCommunicationForm] = useState({
    type: 'email',
    // Basic fields (always shown)
    title: '',
    date: new Date().toISOString().slice(0, 16),
    priority: 'medium', // low, medium, high, critical

    // Common fields
    description: '',
    stakeholderIds: [],
    linkedIssues: [],
    linkedEpics: [],

    // Type-specific fields
    // Email
    from: '',
    to: '',
    cc: '',
    subject: '',
    body: '',

    // Decision
    decisionDate: new Date().toISOString().split('T')[0],
    approvedBy: '',
    documentUrl: '',
    documentVersion: '',

    // Meeting
    attendees: '',
    meetingNotes: '',
    actionItems: '',

    // Incident
    severity: 'medium',
    itoTicketNumber: '',
    itoTicketLink: '',
    resolution: '',
    resolutionDate: '',

    // Advanced fields (collapsed by default)
    tags: [],
    attachments: [],
    supersedes: '',
    timeImpact: '',
    rootCause: ''
  })

  const [showAdvanced, setShowAdvanced] = useState(false)

  // Filter history based on current filters
  const filteredHistory = useMemo(() => {
    let filtered = [...history]

    // Type filter
    if (filterType !== 'all') {
      filtered = filtered.filter(item => item.type === filterType)
    }

    // Date range filter
    if (filterDateRange !== 'all') {
      const now = new Date()
      const cutoff = new Date()

      switch (filterDateRange) {
        case 'today':
          cutoff.setHours(0, 0, 0, 0)
          break
        case 'week':
          cutoff.setDate(cutoff.getDate() - 7)
          break
        case 'month':
          cutoff.setMonth(cutoff.getMonth() - 1)
          break
      }

      filtered = filtered.filter(item => {
        const itemDate = new Date(item.sentAt || item.createdAt)
        return itemDate >= cutoff
      })
    }

    // Search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase()
      filtered = filtered.filter(item => {
        return (
          (item.subject && item.subject.toLowerCase().includes(query)) ||
          (item.title && item.title.toLowerCase().includes(query)) ||
          (item.content && item.content.toLowerCase().includes(query)) ||
          (item.description && item.description.toLowerCase().includes(query))
        )
      })
    }

    return filtered
  }, [history, filterType, filterDateRange, searchQuery])

  // Group history by date for timeline view
  const groupedHistory = useMemo(() => {
    const groups = {}
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    const yesterday = new Date(today)
    yesterday.setDate(yesterday.getDate() - 1)

    filteredHistory.forEach(item => {
      const itemDate = new Date(item.sentAt || item.createdAt)
      let groupKey

      if (itemDate >= today) {
        groupKey = 'Today'
      } else if (itemDate >= yesterday) {
        groupKey = 'Yesterday'
      } else {
        groupKey = itemDate.toLocaleDateString('en-GB', {
          day: 'numeric',
          month: 'short',
          year: 'numeric'
        })
      }

      if (!groups[groupKey]) {
        groups[groupKey] = []
      }
      groups[groupKey].push(item)
    })

    // Sort groups by date (most recent first)
    const sortedGroups = Object.entries(groups).sort((a, b) => {
      if (a[0] === 'Today') return -1
      if (b[0] === 'Today') return 1
      if (a[0] === 'Yesterday') return -1
      if (b[0] === 'Yesterday') return 1
      return new Date(b[0]) - new Date(a[0])
    })

    return sortedGroups
  }, [filteredHistory])

  const handleSubmit = () => {
    const form = communicationForm

    // Build communication object based on type
    const communication = {
      type: form.type,
      sentAt: new Date(form.date).toISOString(),
      priority: form.priority,
      stakeholderIds: form.stakeholderIds,
      linkedIssues: form.linkedIssues,
      linkedEpics: form.linkedEpics,
      tags: form.tags,
      attachments: form.attachments
    }

    // Add type-specific fields
    switch (form.type) {
      case 'email':
        communication.subject = form.subject
        communication.content = form.body
        communication.from = form.from
        communication.to = form.to
        communication.cc = form.cc
        break

      case 'decision':
        communication.title = form.title
        communication.description = form.description
        communication.decisionDate = form.decisionDate
        communication.approvedBy = form.approvedBy
        communication.documentUrl = form.documentUrl
        communication.documentVersion = form.documentVersion
        break

      case 'meeting_notes':
        communication.title = form.title
        communication.content = form.meetingNotes
        communication.attendees = form.attendees
        communication.actionItems = form.actionItems
        break

      case 'incident':
        communication.title = form.title
        communication.description = form.description
        communication.severity = form.severity
        communication.itoTicketNumber = form.itoTicketNumber
        communication.itoTicketLink = form.itoTicketLink
        communication.resolution = form.resolution
        communication.resolutionDate = form.resolutionDate
        break

      default:
        communication.title = form.title
        communication.description = form.description
        break
    }

    // Save based on type
    if (form.type === 'decision') {
      saveDecision(communication)
    } else {
      logCommunication(communication)
    }

    // Update history
    if (onHistoryUpdate) {
      onHistoryUpdate()
    }

    // Reset form and switch back to timeline
    resetForm()
    setViewMode('timeline')
  }

  const resetForm = () => {
    const now = new Date()
    const newDate = now.toISOString().slice(0, 16)
    setCommunicationForm({
      type: 'email',
      title: '',
      date: newDate,
      priority: 'medium',
      description: '',
      stakeholderIds: [],
      linkedIssues: [],
      linkedEpics: [],
      from: '',
      to: '',
      cc: '',
      subject: '',
      body: '',
      decisionDate: new Date().toISOString().split('T')[0],
      approvedBy: '',
      documentUrl: '',
      documentVersion: '',
      attendees: '',
      meetingNotes: '',
      actionItems: '',
      severity: 'medium',
      itoTicketNumber: '',
      itoTicketLink: '',
      resolution: '',
      resolutionDate: '',
      tags: [],
      attachments: [],
      supersedes: '',
      timeImpact: '',
      rootCause: ''
    })
    setShowAdvanced(false)
  }

  const getTypeColor = (type) => {
    const typeConfig = Object.values(COMMUNICATION_TYPES).find(t => t.id === type)
    return typeConfig ? typeConfig.color : '#6B7280'
  }

  const getTypeLabel = (type) => {
    const typeConfig = Object.values(COMMUNICATION_TYPES).find(t => t.id === type)
    return typeConfig ? typeConfig.label : type
  }

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'critical': return '#DC2626'
      case 'high': return '#F59E0B'
      case 'medium': return '#3B82F6'
      case 'low': return '#6B7280'
      default: return '#6B7280'
    }
  }

  // Calculate duration for Gantt chart items
  const getItemDuration = (item) => {
    const startDate = new Date(item.sentAt || item.createdAt || item.decisionDate)
    let endDate = null

    // Determine end date based on type
    if (item.type === 'incident' && item.resolutionDate) {
      endDate = new Date(item.resolutionDate)
    } else if (item.type === 'scope_change' && item.newDate) {
      endDate = new Date(item.newDate)
    } else if (item.type === 'decision' && item.implementationDate) {
      endDate = new Date(item.implementationDate)
    } else if (item.timeImpact) {
      // Parse time impact (e.g., "+2 days", "1 week")
      const impact = item.timeImpact.toLowerCase()
      endDate = new Date(startDate)
      if (impact.includes('day')) {
        const days = parseInt(impact.match(/\d+/)?.[0] || 1)
        endDate.setDate(endDate.getDate() + days)
      } else if (impact.includes('week')) {
        const weeks = parseInt(impact.match(/\d+/)?.[0] || 1)
        endDate.setDate(endDate.getDate() + (weeks * 7))
      }
    }

    // Default duration for items without explicit end date
    if (!endDate) {
      endDate = new Date(startDate)
      // Single-day events show as 1-day bars
      endDate.setDate(endDate.getDate() + 1)
    }

    return { startDate, endDate }
  }

  // Calculate date range based on year and quarters
  const getQuarterDateRange = (year, quarters) => {
    const minQuarter = Math.min(...quarters)
    const maxQuarter = Math.max(...quarters)

    const start = new Date(year, (minQuarter - 1) * 3, 1)
    const end = new Date(year, maxQuarter * 3, 0) // Last day of the last quarter

    return { start, end }
  }

  // Get available years from data
  const availableYears = useMemo(() => {
    const years = new Set()
    const currentYear = new Date().getFullYear()

    filteredHistory.forEach(item => {
      const itemDate = new Date(item.sentAt || item.createdAt || item.decisionDate)
      years.add(itemDate.getFullYear())
    })

    // Always include current year and next year
    years.add(currentYear)
    years.add(currentYear + 1)
    years.add(currentYear - 1)

    return Array.from(years).sort((a, b) => b - a)
  }, [filteredHistory])

  // Prepare data for Gantt chart
  const ganttData = useMemo(() => {
    if (timelineView !== 'gantt') return []

    // Get date range based on selected year and quarters
    const { start: rangeStart, end: rangeEnd } = getQuarterDateRange(ganttYear, ganttQuarters)

    // Filter items to those within the selected date range
    const items = filteredHistory
      .map(item => {
        const { startDate, endDate } = getItemDuration(item)
        return {
          ...item,
          startDate,
          endDate,
          duration: Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) // days
        }
      })
      .filter(item => {
        // Show items that overlap with the selected date range
        return item.startDate <= rangeEnd && item.endDate >= rangeStart
      })

    // Set the gantt range to the quarter range with some padding
    const paddedStart = new Date(rangeStart)
    const paddedEnd = new Date(rangeEnd)
    paddedStart.setDate(paddedStart.getDate() - 7)
    paddedEnd.setDate(paddedEnd.getDate() + 7)

    setGanttRange({ start: paddedStart, end: paddedEnd })

    return items
  }, [filteredHistory, timelineView, ganttYear, ganttQuarters])

  return (
    <div>
      {/* Modal for Communication Details */}
      {selectedItem && (
        <div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0, 0, 0, 0.5)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: '20px'
          }}
          onClick={() => setSelectedItem(null)}
        >
          <div
            style={{
              background: 'white',
              borderRadius: '8px',
              maxWidth: '700px',
              width: '100%',
              maxHeight: '90vh',
              overflow: 'auto',
              boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)'
            }}
            onClick={(e) => e.stopPropagation()}
          >
            {/* Modal Header */}
            <div style={{
              padding: '20px 24px',
              borderBottom: '1px solid #E5E7EB',
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'flex-start'
            }}>
              <div style={{ flex: 1 }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                  <span style={{
                    padding: '4px 10px',
                    background: getTypeColor(selectedItem.type) + '20',
                    color: getTypeColor(selectedItem.type),
                    borderRadius: '4px',
                    fontSize: '12px',
                    fontWeight: '600',
                    textTransform: 'uppercase'
                  }}>
                    {getTypeLabel(selectedItem.type)}
                  </span>
                  {selectedItem.priority && (
                    <span style={{
                      padding: '4px 10px',
                      background: getPriorityColor(selectedItem.priority) + '20',
                      color: getPriorityColor(selectedItem.priority),
                      borderRadius: '4px',
                      fontSize: '12px',
                      fontWeight: '600',
                      textTransform: 'uppercase'
                    }}>
                      {selectedItem.priority}
                    </span>
                  )}
                </div>
                <h3 style={{ fontSize: '18px', fontWeight: '600', color: '#111827' }}>
                  {selectedItem.subject || selectedItem.title || 'Untitled'}
                </h3>
              </div>
              <button
                onClick={() => setSelectedItem(null)}
                style={{
                  background: 'transparent',
                  border: 'none',
                  fontSize: '24px',
                  color: '#6B7280',
                  cursor: 'pointer',
                  padding: '0 4px',
                  lineHeight: '1'
                }}
              >
                √ó
              </button>
            </div>

            {/* Modal Body */}
            <div style={{ padding: '24px' }}>
              {/* Date and Time */}
              <div style={{ marginBottom: '20px' }}>
                <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                  Date & Time
                </label>
                <div style={{ fontSize: '14px', color: '#374151' }}>
                  {new Date(selectedItem.sentAt || selectedItem.createdAt || selectedItem.decisionDate).toLocaleDateString('en-GB', {
                    day: '2-digit',
                    month: 'long',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                  })}
                </div>
              </div>

              {/* Type-specific fields */}
              {selectedItem.type === 'email' && (
                <>
                  {selectedItem.from && (
                    <div style={{ marginBottom: '20px' }}>
                      <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                        From
                      </label>
                      <div style={{ fontSize: '14px', color: '#374151' }}>
                        {selectedItem.from}
                      </div>
                    </div>
                  )}
                  {selectedItem.to && (
                    <div style={{ marginBottom: '20px' }}>
                      <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                        To
                      </label>
                      <div style={{ fontSize: '14px', color: '#374151' }}>
                        {selectedItem.to}
                      </div>
                    </div>
                  )}
                  {selectedItem.cc && (
                    <div style={{ marginBottom: '20px' }}>
                      <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                        CC
                      </label>
                      <div style={{ fontSize: '14px', color: '#374151' }}>
                        {selectedItem.cc}
                      </div>
                    </div>
                  )}
                </>
              )}

              {selectedItem.type === 'decision' && (
                <>
                  {selectedItem.approvedBy && selectedItem.approvedBy.length > 0 && (
                    <div style={{ marginBottom: '20px' }}>
                      <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                        Approved By
                      </label>
                      <div style={{ fontSize: '14px', color: '#374151' }}>
                        {Array.isArray(selectedItem.approvedBy) ? selectedItem.approvedBy.join(', ') : selectedItem.approvedBy}
                      </div>
                    </div>
                  )}
                  {selectedItem.documentUrl && (
                    <div style={{ marginBottom: '20px' }}>
                      <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                        Document
                      </label>
                      <a href={selectedItem.documentUrl} target="_blank" rel="noopener noreferrer" style={{ fontSize: '14px', color: '#3B82F6', textDecoration: 'underline' }}>
                        View Document {selectedItem.documentVersion && `(v${selectedItem.documentVersion})`}
                      </a>
                    </div>
                  )}
                </>
              )}

              {selectedItem.type === 'meeting_notes' && (
                <>
                  {selectedItem.attendees && (
                    <div style={{ marginBottom: '20px' }}>
                      <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                        Attendees
                      </label>
                      <div style={{ fontSize: '14px', color: '#374151' }}>
                        {selectedItem.attendees}
                      </div>
                    </div>
                  )}
                  {selectedItem.actionItems && (
                    <div style={{ marginBottom: '20px' }}>
                      <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                        Action Items
                      </label>
                      <div style={{ fontSize: '14px', color: '#374151', whiteSpace: 'pre-wrap' }}>
                        {selectedItem.actionItems}
                      </div>
                    </div>
                  )}
                </>
              )}

              {selectedItem.type === 'incident' && (
                <>
                  {selectedItem.severity && (
                    <div style={{ marginBottom: '20px' }}>
                      <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                        Severity
                      </label>
                      <span style={{
                        padding: '4px 10px',
                        background: getPriorityColor(selectedItem.severity) + '20',
                        color: getPriorityColor(selectedItem.severity),
                        borderRadius: '4px',
                        fontSize: '12px',
                        fontWeight: '600',
                        textTransform: 'uppercase'
                      }}>
                        {selectedItem.severity}
                      </span>
                    </div>
                  )}
                  {selectedItem.itoTicketNumber && (
                    <div style={{ marginBottom: '20px' }}>
                      <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                        ITO Ticket
                      </label>
                      <div style={{ fontSize: '14px', color: '#374151' }}>
                        {selectedItem.itoTicketLink ? (
                          <a href={selectedItem.itoTicketLink} target="_blank" rel="noopener noreferrer" style={{ color: '#3B82F6', textDecoration: 'underline' }}>
                            {selectedItem.itoTicketNumber}
                          </a>
                        ) : (
                          selectedItem.itoTicketNumber
                        )}
                      </div>
                    </div>
                  )}
                  {selectedItem.resolution && (
                    <div style={{ marginBottom: '20px' }}>
                      <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                        Resolution
                      </label>
                      <div style={{ fontSize: '14px', color: '#374151', whiteSpace: 'pre-wrap' }}>
                        {selectedItem.resolution}
                      </div>
                    </div>
                  )}
                  {selectedItem.resolutionDate && (
                    <div style={{ marginBottom: '20px' }}>
                      <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                        Resolution Date
                      </label>
                      <div style={{ fontSize: '14px', color: '#374151' }}>
                        {new Date(selectedItem.resolutionDate).toLocaleDateString('en-GB', {
                          day: '2-digit',
                          month: 'long',
                          year: 'numeric'
                        })}
                      </div>
                    </div>
                  )}
                </>
              )}

              {/* Content/Description */}
              {(selectedItem.content || selectedItem.description || selectedItem.body) && (
                <div style={{ marginBottom: '20px' }}>
                  <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                    {selectedItem.type === 'email' ? 'Message' : selectedItem.type === 'meeting_notes' ? 'Notes' : 'Description'}
                  </label>
                  <div style={{
                    fontSize: '14px',
                    color: '#374151',
                    lineHeight: '1.6',
                    whiteSpace: 'pre-wrap',
                    padding: '12px',
                    background: '#F9FAFB',
                    borderRadius: '6px',
                    border: '1px solid #E5E7EB'
                  }}>
                    {selectedItem.content || selectedItem.description || selectedItem.body}
                  </div>
                </div>
              )}

              {/* Stakeholders */}
              {selectedItem.stakeholderIds && selectedItem.stakeholderIds.length > 0 && (
                <div style={{ marginBottom: '20px' }}>
                  <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                    Related Stakeholders
                  </label>
                  <div style={{ fontSize: '14px', color: '#374151' }}>
                    {selectedItem.stakeholderIds.length} stakeholder(s)
                  </div>
                </div>
              )}

              {/* Linked Issues/Epics */}
              {((selectedItem.linkedIssues && selectedItem.linkedIssues.length > 0) || (selectedItem.linkedEpics && selectedItem.linkedEpics.length > 0)) && (
                <div style={{ marginBottom: '20px' }}>
                  <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                    Linked Items
                  </label>
                  <div style={{ fontSize: '14px', color: '#374151' }}>
                    {selectedItem.linkedIssues && selectedItem.linkedIssues.length > 0 && (
                      <div>{selectedItem.linkedIssues.length} issue(s)</div>
                    )}
                    {selectedItem.linkedEpics && selectedItem.linkedEpics.length > 0 && (
                      <div>{selectedItem.linkedEpics.length} epic(s)</div>
                    )}
                  </div>
                </div>
              )}

              {/* Tags */}
              {selectedItem.tags && selectedItem.tags.length > 0 && (
                <div style={{ marginBottom: '20px' }}>
                  <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                    Tags
                  </label>
                  <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
                    {selectedItem.tags.map((tag, index) => (
                      <span key={index} style={{
                        padding: '4px 10px',
                        background: '#E5E7EB',
                        color: '#374151',
                        borderRadius: '4px',
                        fontSize: '12px',
                        fontWeight: '500'
                      }}>
                        {tag}
                      </span>
                    ))}
                  </div>
                </div>
              )}

              {/* Additional fields */}
              {selectedItem.timeImpact && (
                <div style={{ marginBottom: '20px' }}>
                  <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                    Time Impact
                  </label>
                  <div style={{ fontSize: '14px', color: '#374151' }}>
                    {selectedItem.timeImpact}
                  </div>
                </div>
              )}

              {selectedItem.rootCause && (
                <div style={{ marginBottom: '20px' }}>
                  <label style={{ fontSize: '12px', fontWeight: '600', color: '#6B7280', display: 'block', marginBottom: '6px', textTransform: 'uppercase' }}>
                    Root Cause
                  </label>
                  <div style={{ fontSize: '14px', color: '#374151', whiteSpace: 'pre-wrap' }}>
                    {selectedItem.rootCause}
                  </div>
                </div>
              )}
            </div>

            {/* Modal Footer */}
            <div style={{
              padding: '16px 24px',
              borderTop: '1px solid #E5E7EB',
              display: 'flex',
              justifyContent: 'flex-end'
            }}>
              <button
                onClick={() => setSelectedItem(null)}
                className="btn btn-primary"
                style={{
                  padding: '8px 16px',
                  fontSize: '14px',
                  fontWeight: '500'
                }}
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Header with view toggle */}
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '24px'
      }}>
        <div>
          <h2 style={{ fontSize: '20px', fontWeight: '600', marginBottom: '4px' }}>
            Communications
          </h2>
          <p style={{ fontSize: '13px', color: '#6B7280' }}>
            {viewMode === 'timeline'
              ? 'View and manage all communications and decisions'
              : 'Log new communication or decision'}
          </p>
        </div>

        <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
          {/* Quick Create Button */}
          <button
            onClick={() => {
              if (viewMode === 'create') {
                // When going back to timeline, reset Gantt filters to show current period
                // But use the year that actually has data
                const now = new Date()
                const currentQuarter = Math.ceil((now.getMonth() + 1) / 3)

                // If we have history, check what year has the most recent data
                if (filteredHistory && filteredHistory.length > 0) {
                  const mostRecent = filteredHistory[0]
                  const date = new Date(mostRecent.sentAt || mostRecent.createdAt || mostRecent.decisionDate)
                  setGanttYear(date.getFullYear())
                } else {
                  setGanttYear(now.getFullYear())
                }
                setGanttQuarters([currentQuarter])
              }
              setViewMode(viewMode === 'timeline' ? 'create' : 'timeline')
            }}
            className="btn btn-primary"
            style={{
              padding: '8px 16px',
              fontSize: '14px',
              fontWeight: '500',
              display: 'flex',
              alignItems: 'center',
              gap: '6px'
            }}
          >
            {viewMode === 'timeline' ? '+ New Entry' : '‚Üê Back to Timeline'}
          </button>

          {/* List/Gantt View Toggle - Only show in timeline mode */}
          {viewMode === 'timeline' && (
            <div style={{
              display: 'flex',
              background: '#F3F4F6',
              borderRadius: '6px',
              padding: '2px'
            }}>
              <button
                onClick={() => setTimelineView('list')}
                style={{
                  padding: '6px 12px',
                  background: timelineView === 'list' ? 'white' : 'transparent',
                  border: 'none',
                  borderRadius: '4px',
                  fontSize: '13px',
                  fontWeight: '500',
                  color: timelineView === 'list' ? '#111827' : '#6B7280',
                  cursor: 'pointer',
                  transition: 'all 0.2s ease'
                }}
              >
                List View
              </button>
              <button
                onClick={() => setTimelineView('gantt')}
                style={{
                  padding: '6px 12px',
                  background: timelineView === 'gantt' ? 'white' : 'transparent',
                  border: 'none',
                  borderRadius: '4px',
                  fontSize: '13px',
                  fontWeight: '500',
                  color: timelineView === 'gantt' ? '#111827' : '#6B7280',
                  cursor: 'pointer',
                  transition: 'all 0.2s ease'
                }}
              >
                Gantt View
              </button>
            </div>
          )}
        </div>
      </div>

      {/* Timeline View */}
      {viewMode === 'timeline' && (
        <>
          {/* Filters Bar */}
          <div style={{
            marginBottom: '16px',
            padding: '16px',
            background: '#F9FAFB',
            borderRadius: '8px',
            display: 'flex',
            gap: '12px',
            flexWrap: 'wrap',
            alignItems: 'center'
          }}>
            {/* Type Filter */}
            <select
              value={filterType}
              onChange={(e) => setFilterType(e.target.value)}
              style={{
                padding: '6px 12px',
                border: '1px solid #D1D5DB',
                borderRadius: '6px',
                fontSize: '13px',
                background: 'white'
              }}
            >
              <option value="all">All Types</option>
              {Object.values(COMMUNICATION_TYPES).map(type => (
                <option key={type.id} value={type.id}>{type.label}</option>
              ))}
            </select>

            {/* Date Range Filter */}
            <select
              value={filterDateRange}
              onChange={(e) => setFilterDateRange(e.target.value)}
              style={{
                padding: '6px 12px',
                border: '1px solid #D1D5DB',
                borderRadius: '6px',
                fontSize: '13px',
                background: 'white'
              }}
            >
              <option value="all">All Time</option>
              <option value="today">Today</option>
              <option value="week">Last 7 Days</option>
              <option value="month">Last Month</option>
            </select>

            {/* Search */}
            <input
              type="text"
              placeholder="Search communications..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              style={{
                flex: 1,
                minWidth: '200px',
                padding: '6px 12px',
                border: '1px solid #D1D5DB',
                borderRadius: '6px',
                fontSize: '13px'
              }}
            />

            {/* Results Count */}
            <div style={{ fontSize: '13px', color: '#6B7280' }}>
              {filteredHistory.length} {filteredHistory.length === 1 ? 'item' : 'items'}
            </div>
          </div>

          {/* Timeline Content - List or Gantt */}
          {timelineView === 'list' && groupedHistory.length === 0 ? (
            <div className="card text-center" style={{ padding: '60px 20px' }}>
              <h3 style={{ marginBottom: '8px', color: '#374151' }}>No Communications Yet</h3>
              <p style={{ color: '#6B7280', marginBottom: '16px' }}>
                Start logging communications to build your activity timeline
              </p>
              <button
                onClick={() => setViewMode('create')}
                className="btn btn-primary"
              >
                Create First Entry
              </button>
            </div>
          ) : timelineView === 'list' ? (
            <div>
              {groupedHistory.map(([date, items]) => (
                <div key={date} style={{ marginBottom: '32px' }}>
                  {/* Date Header */}
                  <div style={{
                    fontSize: '12px',
                    fontWeight: '600',
                    color: '#6B7280',
                    textTransform: 'uppercase',
                    marginBottom: '12px',
                    paddingBottom: '8px',
                    borderBottom: '1px solid #E5E7EB'
                  }}>
                    {date}
                  </div>

                  {/* Items for this date */}
                  {items.map(item => (
                    <div
                      key={item.id}
                      onClick={() => setSelectedItem(item)}
                      style={{
                        padding: '12px',
                        marginBottom: '8px',
                        background: 'white',
                        border: '1px solid #E5E7EB',
                        borderRadius: '6px',
                        cursor: 'pointer',
                        transition: 'all 0.2s ease',
                        ':hover': {
                          borderColor: '#D1D5DB',
                          boxShadow: '0 1px 3px 0 rgba(0, 0, 0, 0.1)'
                        }
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.borderColor = '#D1D5DB'
                        e.currentTarget.style.boxShadow = '0 1px 3px 0 rgba(0, 0, 0, 0.1)'
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.borderColor = '#E5E7EB'
                        e.currentTarget.style.boxShadow = 'none'
                      }}
                    >
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                        <div style={{ flex: 1 }}>
                          {/* Type and Time */}
                          <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '6px' }}>
                            <span style={{
                              padding: '2px 8px',
                              background: getTypeColor(item.type) + '20',
                              color: getTypeColor(item.type),
                              borderRadius: '4px',
                              fontSize: '11px',
                              fontWeight: '600',
                              textTransform: 'uppercase'
                            }}>
                              {getTypeLabel(item.type)}
                            </span>
                            <span style={{ fontSize: '12px', color: '#6B7280' }}>
                              {new Date(item.sentAt || item.createdAt).toLocaleTimeString('en-GB', {
                                hour: '2-digit',
                                minute: '2-digit'
                              })}
                            </span>
                            {item.priority && item.priority !== 'medium' && (
                              <span style={{
                                padding: '2px 6px',
                                background: getPriorityColor(item.priority) + '20',
                                color: getPriorityColor(item.priority),
                                borderRadius: '4px',
                                fontSize: '11px',
                                fontWeight: '500'
                              }}>
                                {item.priority}
                              </span>
                            )}
                          </div>

                          {/* Title/Subject */}
                          <div style={{
                            fontSize: '14px',
                            fontWeight: '500',
                            color: '#111827',
                            marginBottom: '4px'
                          }}>
                            {item.subject || item.title || 'Untitled'}
                          </div>

                          {/* Preview/Description */}
                          {(item.content || item.description) && (
                            <div style={{
                              fontSize: '13px',
                              color: '#6B7280',
                              lineHeight: '1.4',
                              display: '-webkit-box',
                              WebkitLineClamp: 2,
                              WebkitBoxOrient: 'vertical',
                              overflow: 'hidden'
                            }}>
                              {item.content || item.description}
                            </div>
                          )}

                          {/* Meta Info */}
                          <div style={{
                            display: 'flex',
                            gap: '12px',
                            marginTop: '8px',
                            fontSize: '12px',
                            color: '#9CA3AF'
                          }}>
                            {item.from && (
                              <span>From: {item.from}</span>
                            )}
                            {item.stakeholderIds && item.stakeholderIds.length > 0 && (
                              <span>{item.stakeholderIds.length} stakeholder(s)</span>
                            )}
                            {item.tags && item.tags.length > 0 && (
                              <span>{item.tags.length} tag(s)</span>
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              ))}
            </div>
          ) : (
            // Gantt Chart View
            <div className="card" style={{ padding: '20px', overflowX: 'auto' }}>
              {/* Gantt Chart Header */}
              <div style={{ marginBottom: '20px' }}>
                <h3 style={{ fontSize: '16px', fontWeight: '600', marginBottom: '8px' }}>
                  Communication Timeline
                </h3>
                <p style={{ fontSize: '12px', color: '#6B7280' }}>
                  {ganttData.length > 0 ? `Showing ${ganttData.length} items with duration information` : 'Select a time period to view communications'}
                </p>
              </div>

              {/* Year and Quarter Filters - Always visible */}
                  <div style={{
                    marginBottom: '20px',
                    padding: '16px',
                    background: '#F9FAFB',
                    borderRadius: '6px',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '20px'
                  }}>
                    {/* Year Selector */}
                    <div>
                      <label style={{ fontSize: '12px', color: '#374151', fontWeight: '500', marginRight: '8px' }}>
                        Year:
                      </label>
                      <select
                        value={ganttYear}
                        onChange={(e) => setGanttYear(parseInt(e.target.value))}
                        style={{
                          padding: '6px 12px',
                          borderRadius: '4px',
                          border: '1px solid #D1D5DB',
                          fontSize: '13px',
                          background: 'white'
                        }}
                      >
                        {availableYears.map(year => (
                          <option key={year} value={year}>{year}</option>
                        ))}
                      </select>
                    </div>

                    {/* Quarter Selector */}
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <label style={{ fontSize: '12px', color: '#374151', fontWeight: '500', marginRight: '8px' }}>
                        Period:
                      </label>
                      <div style={{ display: 'flex', gap: '6px' }}>
                        {/* Full Year Button */}
                        <button
                          onClick={() => setGanttQuarters([1, 2, 3, 4])}
                          style={{
                            padding: '6px 12px',
                            borderRadius: '4px',
                            border: '1px solid',
                            borderColor: ganttQuarters.length === 4 ? '#10B981' : '#D1D5DB',
                            background: ganttQuarters.length === 4 ? '#10B981' : 'white',
                            color: ganttQuarters.length === 4 ? 'white' : '#374151',
                            fontSize: '12px',
                            fontWeight: '500',
                            cursor: 'pointer',
                            transition: 'all 0.2s ease'
                          }}
                        >
                          Full Year
                        </button>

                        <div style={{ width: '1px', background: '#E5E7EB', margin: '0 4px' }} />

                        {/* Quarter Buttons */}
                        {[1, 2, 3, 4].map(quarter => (
                          <button
                            key={quarter}
                            onClick={() => {
                              // Clicking a quarter selects only that quarter
                              setGanttQuarters([quarter])
                            }}
                            style={{
                              padding: '6px 12px',
                              borderRadius: '4px',
                              border: '1px solid',
                              borderColor: ganttQuarters.includes(quarter) ? '#3B82F6' : '#D1D5DB',
                              background: ganttQuarters.includes(quarter) ? '#3B82F6' : 'white',
                              color: ganttQuarters.includes(quarter) ? 'white' : '#374151',
                              fontSize: '12px',
                              fontWeight: '500',
                              cursor: 'pointer',
                              transition: 'all 0.2s ease'
                            }}
                          >
                            Q{quarter}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Date Range Info */}
                    <div style={{ marginLeft: 'auto', fontSize: '12px', color: '#6B7280' }}>
                      {(() => {
                        const range = getQuarterDateRange(ganttYear, ganttQuarters)
                        return `${range.start.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' })} - ${range.end.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' })}`
                      })()}
                    </div>
                  </div>

              {/* Gantt Chart Content or Empty State */}
              {ganttData.length === 0 ? (
                <div style={{ textAlign: 'center', padding: '40px', color: '#6B7280' }}>
                  <div style={{ marginBottom: '12px', fontSize: '14px' }}>
                    No communications found for {ganttQuarters.length === 1 ? `Q${ganttQuarters[0]}` : ganttQuarters.length === 4 ? 'the year' : `Q${ganttQuarters.join(', Q')}`} {ganttYear}
                  </div>
                  <div style={{ fontSize: '12px' }}>
                    Try selecting a different time period or year
                  </div>
                </div>
              ) : (
                <>
                  {/* Gantt Chart */}
                  <div style={{ position: 'relative', minWidth: '800px' }}>
                    {/* Date Header */}
                    {ganttRange.start && ganttRange.end && (
                      <div style={{
                        display: 'flex',
                        borderBottom: '2px solid #E5E7EB',
                        marginBottom: '8px',
                        paddingBottom: '8px'
                      }}>
                        <div style={{ width: '200px', fontSize: '12px', fontWeight: '600', color: '#374151' }}>
                          Item
                        </div>
                        <div style={{ flex: 1, display: 'flex', justifyContent: 'space-between', fontSize: '11px', color: '#6B7280' }}>
                          {(() => {
                            // Calculate the duration in days
                            const durationDays = Math.ceil((ganttRange.end - ganttRange.start) / (1000 * 60 * 60 * 24))

                            // Smart display logic based on timeframe
                            if (ganttQuarters.length === 1) {
                              // Single quarter: show weeks
                              const weeks = []
                              const current = new Date(ganttRange.start)
                              let weekNum = 1

                              while (current <= ganttRange.end) {
                                const weekStart = new Date(current)
                                const weekEnd = new Date(current)
                                weekEnd.setDate(weekEnd.getDate() + 6)

                                if (weekEnd > ganttRange.end) {
                                  weekEnd.setTime(ganttRange.end.getTime())
                                }

                                weeks.push({
                                  label: `W${weekNum}`,
                                  tooltip: `${weekStart.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })} - ${weekEnd.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })}`
                                })

                                current.setDate(current.getDate() + 7)
                                weekNum++
                              }

                              return weeks.map((week, i) => (
                                <div
                                  key={i}
                                  style={{ flex: 1, textAlign: 'center', cursor: 'help' }}
                                  title={week.tooltip}
                                >
                                  {week.label}
                                </div>
                              ))
                            } else if (ganttQuarters.length === 2) {
                              // Two quarters: show months with week indicators
                              const monthsData = []
                              const current = new Date(ganttRange.start)

                              while (current <= ganttRange.end) {
                                const monthLabel = current.toLocaleDateString('en-GB', { month: 'short' })
                                const monthStart = new Date(current)
                                const monthEnd = new Date(current.getFullYear(), current.getMonth() + 1, 0)

                                // Calculate weeks in this month
                                const weeks = []
                                let weekDate = new Date(monthStart)
                                weekDate.setDate(1) // Start from first of month

                                while (weekDate <= monthEnd && weekDate <= ganttRange.end) {
                                  weeks.push(weekDate.getDate())
                                  weekDate.setDate(weekDate.getDate() + 7)
                                }

                                monthsData.push({
                                  month: monthLabel,
                                  weeks: weeks
                                })

                                current.setMonth(current.getMonth() + 1)
                              }

                              return (
                                <div style={{ display: 'flex', flex: 1 }}>
                                  {monthsData.map((item, i) => (
                                    <div key={i} style={{ flex: 1, borderRight: i < monthsData.length - 1 ? '1px solid #E5E7EB' : 'none' }}>
                                      <div style={{ textAlign: 'center', fontWeight: '600', marginBottom: '4px' }}>
                                        {item.month}
                                      </div>
                                      <div style={{ display: 'flex', fontSize: '9px', color: '#9CA3AF' }}>
                                        {item.weeks.map((week, wi) => (
                                          <div key={wi} style={{ flex: 1, textAlign: 'center' }}>{week}</div>
                                        ))}
                                      </div>
                                    </div>
                                  ))}
                                </div>
                              )
                            } else {
                              // Three or four quarters: show months
                              const months = []
                              const current = new Date(ganttRange.start)

                              while (current <= ganttRange.end) {
                                const isFirstOfYear = current.getMonth() === 0
                                const label = isFirstOfYear
                                  ? current.toLocaleDateString('en-GB', { month: 'short', year: 'numeric' })
                                  : current.toLocaleDateString('en-GB', { month: 'short' })
                                months.push(label)
                                current.setMonth(current.getMonth() + 1)
                              }

                              return months.map((month, i) => (
                                <div key={i} style={{ flex: 1, textAlign: 'center' }}>{month}</div>
                              ))
                            }
                          })()}
                        </div>
                      </div>
                    )}

                    {/* Gantt Rows */}
                    {ganttData.map((item, index) => {
                      const totalDays = ganttRange.end ? Math.ceil((ganttRange.end - ganttRange.start) / (1000 * 60 * 60 * 24)) : 1
                      const startOffset = Math.ceil((item.startDate - ganttRange.start) / (1000 * 60 * 60 * 24))
                      const widthPercent = (item.duration / totalDays) * 100
                      const leftPercent = (startOffset / totalDays) * 100

                      return (
                        <div
                          key={item.id}
                          style={{
                            display: 'flex',
                            alignItems: 'center',
                            marginBottom: '4px',
                            minHeight: '32px',
                            background: index % 2 === 0 ? 'white' : '#F9FAFB',
                            borderRadius: '4px'
                          }}
                        >
                          {/* Item Label */}
                          <div style={{
                            width: '200px',
                            padding: '6px 12px',
                            fontSize: '12px',
                            color: '#374151',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            whiteSpace: 'nowrap'
                          }}>
                            <span style={{
                              padding: '1px 4px',
                              background: getTypeColor(item.type) + '20',
                              color: getTypeColor(item.type),
                              borderRadius: '2px',
                              fontSize: '10px',
                              fontWeight: '600',
                              marginRight: '6px'
                            }}>
                              {getTypeLabel(item.type).substring(0, 3).toUpperCase()}
                            </span>
                            {item.subject || item.title || 'Untitled'}
                          </div>

                          {/* Gantt Bar */}
                          <div style={{ flex: 1, position: 'relative', height: '24px' }}>
                            <div
                              onClick={() => setSelectedItem(item)}
                              style={{
                                position: 'absolute',
                                left: `${leftPercent}%`,
                                width: `${Math.max(widthPercent, 0.5)}%`,
                                height: '20px',
                                background: getTypeColor(item.type),
                                opacity: 0.8,
                                borderRadius: '3px',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                cursor: 'pointer',
                                transition: 'opacity 0.2s ease'
                              }}
                              onMouseEnter={(e) => e.currentTarget.style.opacity = '1'}
                              onMouseLeave={(e) => e.currentTarget.style.opacity = '0.8'}
                              title={`${item.subject || item.title}\n${item.startDate.toLocaleDateString()} - ${item.endDate.toLocaleDateString()}\n(${item.duration} day${item.duration !== 1 ? 's' : ''})`}
                            >
                              {widthPercent > 5 && (
                                <span style={{ fontSize: '10px', color: 'white', fontWeight: '500' }}>
                                  {item.duration}d
                                </span>
                              )}
                            </div>

                            {/* Today Line for this row */}
                            {index === 0 && (() => {
                              const today = new Date()
                              const totalDays = Math.ceil((ganttRange.end - ganttRange.start) / (1000 * 60 * 60 * 24))
                              const todayOffset = Math.ceil((today - ganttRange.start) / (1000 * 60 * 60 * 24))
                              const todayPercent = (todayOffset / totalDays) * 100

                              if (today >= ganttRange.start && today <= ganttRange.end) {
                                return (
                                  <div style={{
                                    position: 'absolute',
                                    left: `${todayPercent}%`,
                                    top: '-8px',
                                    bottom: '-1000px',
                                    width: '2px',
                                    background: '#EF4444',
                                    opacity: 0.5,
                                    pointerEvents: 'none',
                                    zIndex: 10
                                  }}>
                                    <div style={{
                                      position: 'absolute',
                                      top: '-12px',
                                      left: '-20px',
                                      fontSize: '10px',
                                      color: '#EF4444',
                                      fontWeight: '600',
                                      whiteSpace: 'nowrap'
                                    }}>
                                      Today
                                    </div>
                                  </div>
                                )
                              }
                              return null
                            })()}
                          </div>
                        </div>
                      )
                    })}
                  </div>

                  {/* Legend */}
                  <div style={{
                    marginTop: '24px',
                    paddingTop: '16px',
                    borderTop: '1px solid #E5E7EB',
                    display: 'flex',
                    gap: '20px',
                    flexWrap: 'wrap',
                    fontSize: '11px'
                  }}>
                    {Object.values(COMMUNICATION_TYPES).slice(0, 5).map(type => (
                      <div key={type.id} style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                        <div style={{
                          width: '12px',
                          height: '12px',
                          background: type.color,
                          borderRadius: '2px'
                        }} />
                        <span style={{ color: '#6B7280' }}>{type.label}</span>
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
          )}
        </>
      )}

      {/* Create View */}
      {viewMode === 'create' && (
        <div className="card" lang="de-DE">
          <h3 style={{ fontSize: '16px', fontWeight: '600', marginBottom: '20px' }}>
            Create New Entry
          </h3>

          {/* Basic Fields */}
          <div style={{ marginBottom: '24px' }}>
            <h4 style={{ fontSize: '13px', fontWeight: '600', color: '#6B7280', marginBottom: '12px', textTransform: 'uppercase' }}>
              Basic Information
            </h4>

            {/* Type Selection */}
            <div style={{ marginBottom: '16px' }}>
              <label style={{ fontSize: '13px', fontWeight: '500', color: '#374151', display: 'block', marginBottom: '6px' }}>
                Type
              </label>
              <select
                value={communicationForm.type}
                onChange={(e) => setCommunicationForm({ ...communicationForm, type: e.target.value })}
                style={{
                  width: '100%',
                  padding: '8px 12px',
                  border: '1px solid #D1D5DB',
                  borderRadius: '6px',
                  fontSize: '14px'
                }}
              >
                {Object.values(COMMUNICATION_TYPES).map(type => (
                  <option key={type.id} value={type.id}>{type.label}</option>
                ))}
              </select>
            </div>

            {/* Title/Subject (dynamic based on type) */}
            <div style={{ marginBottom: '16px' }}>
              <label style={{ fontSize: '13px', fontWeight: '500', color: '#374151', display: 'block', marginBottom: '6px' }}>
                {communicationForm.type === 'email' ? 'Subject' : 'Title'}
              </label>
              <input
                type="text"
                value={communicationForm.type === 'email' ? communicationForm.subject : communicationForm.title}
                onChange={(e) => setCommunicationForm({
                  ...communicationForm,
                  [communicationForm.type === 'email' ? 'subject' : 'title']: e.target.value
                })}
                placeholder={communicationForm.type === 'email' ? 'Email subject...' : 'Brief title...'}
                style={{
                  width: '100%',
                  padding: '8px 12px',
                  border: '1px solid #D1D5DB',
                  borderRadius: '6px',
                  fontSize: '14px'
                }}
              />
            </div>

            {/* Date and Priority in same row */}
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '16px' }}>
              <div>
                <label style={{ fontSize: '13px', fontWeight: '500', color: '#374151', display: 'block', marginBottom: '6px' }}>
                  Date & Time
                </label>
                <input
                  type="datetime-local"
                  value={communicationForm.date}
                  onChange={(e) => setCommunicationForm({ ...communicationForm, date: e.target.value })}
                  style={{
                    width: '100%',
                    padding: '8px 12px',
                    border: '1px solid #D1D5DB',
                    borderRadius: '6px',
                    fontSize: '14px'
                  }}
                />
              </div>

              <div>
                <label style={{ fontSize: '13px', fontWeight: '500', color: '#374151', display: 'block', marginBottom: '6px' }}>
                  Priority
                </label>
                <select
                  value={communicationForm.priority}
                  onChange={(e) => setCommunicationForm({ ...communicationForm, priority: e.target.value })}
                  style={{
                    width: '100%',
                    padding: '8px 12px',
                    border: '1px solid #D1D5DB',
                    borderRadius: '6px',
                    fontSize: '14px'
                  }}
                >
                  <option value="low">Low</option>
                  <option value="medium">Medium</option>
                  <option value="high">High</option>
                  <option value="critical">Critical</option>
                </select>
              </div>
            </div>
          </div>

          {/* Type-Specific Fields */}
          <div style={{ marginBottom: '24px' }}>
            <h4 style={{ fontSize: '13px', fontWeight: '600', color: '#6B7280', marginBottom: '12px', textTransform: 'uppercase' }}>
              Details
            </h4>

            {/* Dynamic fields based on type */}
            {communicationForm.type === 'email' && (
              <>
                <div style={{ marginBottom: '16px' }}>
                  <label style={{ fontSize: '13px', fontWeight: '500', color: '#374151', display: 'block', marginBottom: '6px' }}>
                    From
                  </label>
                  <input
                    type="text"
                    value={communicationForm.from}
                    onChange={(e) => setCommunicationForm({ ...communicationForm, from: e.target.value })}
                    placeholder="sender@example.com"
                    style={{
                      width: '100%',
                      padding: '8px 12px',
                      border: '1px solid #D1D5DB',
                      borderRadius: '6px',
                      fontSize: '14px'
                    }}
                  />
                </div>

                <div style={{ marginBottom: '16px' }}>
                  <label style={{ fontSize: '13px', fontWeight: '500', color: '#374151', display: 'block', marginBottom: '6px' }}>
                    To
                  </label>
                  <input
                    type="text"
                    value={communicationForm.to}
                    onChange={(e) => setCommunicationForm({ ...communicationForm, to: e.target.value })}
                    placeholder="recipient@example.com"
                    style={{
                      width: '100%',
                      padding: '8px 12px',
                      border: '1px solid #D1D5DB',
                      borderRadius: '6px',
                      fontSize: '14px'
                    }}
                  />
                </div>

                <div style={{ marginBottom: '16px' }}>
                  <label style={{ fontSize: '13px', fontWeight: '500', color: '#374151', display: 'block', marginBottom: '6px' }}>
                    Message
                  </label>
                  <textarea
                    value={communicationForm.body}
                    onChange={(e) => setCommunicationForm({ ...communicationForm, body: e.target.value })}
                    placeholder="Email content..."
                    rows={4}
                    style={{
                      width: '100%',
                      padding: '8px 12px',
                      border: '1px solid #D1D5DB',
                      borderRadius: '6px',
                      fontSize: '14px'
                    }}
                  />
                </div>
              </>
            )}

            {communicationForm.type === 'decision' && (
              <>
                <div style={{ marginBottom: '16px' }}>
                  <label style={{ fontSize: '13px', fontWeight: '500', color: '#374151', display: 'block', marginBottom: '6px' }}>
                    Description
                  </label>
                  <textarea
                    value={communicationForm.description}
                    onChange={(e) => setCommunicationForm({ ...communicationForm, description: e.target.value })}
                    placeholder="Describe the decision and its rationale..."
                    rows={3}
                    style={{
                      width: '100%',
                      padding: '8px 12px',
                      border: '1px solid #D1D5DB',
                      borderRadius: '6px',
                      fontSize: '14px'
                    }}
                  />
                </div>

                <div style={{ marginBottom: '16px' }}>
                  <label style={{ fontSize: '13px', fontWeight: '500', color: '#374151', display: 'block', marginBottom: '6px' }}>
                    Approved By
                  </label>
                  <input
                    type="text"
                    value={Array.isArray(communicationForm.approvedBy) ? communicationForm.approvedBy.join(', ') : communicationForm.approvedBy || ''}
                    onChange={(e) => setCommunicationForm({
                      ...communicationForm,
                      approvedBy: e.target.value
                    })}
                    placeholder="John Doe, Jane Smith, etc."
                    style={{
                      width: '100%',
                      padding: '8px 12px',
                      border: '1px solid #D1D5DB',
                      borderRadius: '6px',
                      fontSize: '14px'
                    }}
                  />
                </div>
              </>
            )}

            {/* Add more type-specific fields as needed */}
            {!['email', 'decision'].includes(communicationForm.type) && (
              <div style={{ marginBottom: '16px' }}>
                <label style={{ fontSize: '13px', fontWeight: '500', color: '#374151', display: 'block', marginBottom: '6px' }}>
                  Description
                </label>
                <textarea
                  value={communicationForm.description}
                  onChange={(e) => setCommunicationForm({ ...communicationForm, description: e.target.value })}
                  placeholder="Enter details..."
                  rows={4}
                  style={{
                    width: '100%',
                    padding: '8px 12px',
                    border: '1px solid #D1D5DB',
                    borderRadius: '6px',
                    fontSize: '14px'
                  }}
                />
              </div>
            )}
          </div>

          {/* Advanced Options (Collapsible) */}
          <div style={{ marginBottom: '24px' }}>
            <button
              onClick={() => setShowAdvanced(!showAdvanced)}
              style={{
                fontSize: '13px',
                fontWeight: '500',
                color: '#6B7280',
                background: 'none',
                border: 'none',
                padding: 0,
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '6px'
              }}
            >
              {showAdvanced ? '‚ñº' : '‚ñ∂'} Advanced Options
            </button>

            {showAdvanced && (
              <div style={{ marginTop: '12px', paddingLeft: '16px' }}>
                {/* Tags, Links, Attachments, etc. */}
                <p style={{ fontSize: '13px', color: '#6B7280' }}>
                  Advanced options for tags, links, and attachments will be shown here
                </p>
              </div>
            )}
          </div>

          {/* Action Buttons */}
          <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
            <button
              onClick={() => {
                resetForm()
                setViewMode('timeline')
              }}
              style={{
                padding: '8px 16px',
                background: 'white',
                border: '1px solid #D1D5DB',
                borderRadius: '6px',
                fontSize: '14px',
                fontWeight: '500',
                color: '#374151',
                cursor: 'pointer'
              }}
            >
              Cancel
            </button>
            <button
              onClick={handleSubmit}
              className="btn btn-primary"
              style={{
                padding: '8px 16px',
                fontSize: '14px',
                fontWeight: '500'
              }}
            >
              Save Entry
            </button>
          </div>
        </div>
      )}
    </div>
  )
}
```

---


## FILE: src/components/DebugPanel.jsx

```javascript
import React, { useState, useEffect } from 'react'
import { loadConfig, getAllProjects, getAllGroups } from '../services/storageService'

/**
 * Debug Panel - Shows diagnostic information
 * Press Ctrl+Alt+D to toggle (or Cmd+Alt+D on Mac)
 */
export default function DebugPanel({ externalVisible, onToggle }) {
  const [visible, setVisible] = useState(false)
  const [debugInfo, setDebugInfo] = useState({})

  // Use external visibility if provided
  const isVisible = externalVisible !== undefined ? externalVisible : visible
  const toggleVisible = onToggle || setVisible

  // Toggle panel with Ctrl+Alt+D (or Cmd+Alt+D on Mac)
  useEffect(() => {
    const handleKeyPress = (e) => {
      // Use metaKey for Mac (Cmd) or ctrlKey for Windows/Linux
      const modifierKey = e.metaKey || e.ctrlKey
      if (modifierKey && e.altKey && (e.key === 'd' || e.key === 'D')) {
        e.preventDefault() // Prevent any default browser behavior
        const newVisible = !isVisible
        if (onToggle) {
          onToggle(newVisible)
        } else {
          setVisible(newVisible)
        }
        if (newVisible) {
          collectDebugInfo()
        }
      }
    }

    window.addEventListener('keydown', handleKeyPress)
    return () => window.removeEventListener('keydown', handleKeyPress)
  }, [isVisible, onToggle])

  const collectDebugInfo = () => {
    console.log('üîç DEBUG PANEL: Collecting diagnostic information...')

    const info = {
      timestamp: new Date().toISOString(),
      browser: {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        cookiesEnabled: navigator.cookieEnabled,
        onLine: navigator.onLine
      },
      localStorage: {
        available: typeof localStorage !== 'undefined',
        itemCount: 0,
        keys: [],
        totalSize: 0
      },
      config: null,
      projects: [],
      groups: [],
      errors: []
    }

    // Check localStorage
    try {
      if (typeof localStorage !== 'undefined') {
        info.localStorage.itemCount = localStorage.length
        info.localStorage.keys = Object.keys(localStorage)

        // Calculate total size
        let totalSize = 0
        for (let key in localStorage) {
          if (localStorage.hasOwnProperty(key)) {
            totalSize += localStorage[key].length + key.length
          }
        }
        info.localStorage.totalSize = totalSize

        console.log('‚úÖ localStorage available:', info.localStorage)
      } else {
        console.error('‚ùå localStorage NOT available')
        info.errors.push('localStorage is not available')
      }
    } catch (err) {
      console.error('‚ùå Error accessing localStorage:', err)
      info.errors.push(`localStorage error: ${err.message}`)
    }

    // Load configuration
    try {
      info.config = loadConfig()
      console.log('‚úÖ Configuration loaded:', info.config)
    } catch (err) {
      console.error('‚ùå Error loading config:', err)
      info.errors.push(`Config error: ${err.message}`)
    }

    // Load projects
    try {
      info.projects = getAllProjects()
      console.log('‚úÖ Projects loaded:', info.projects.length)
    } catch (err) {
      console.error('‚ùå Error loading projects:', err)
      info.errors.push(`Projects error: ${err.message}`)
    }

    // Load groups
    try {
      info.groups = getAllGroups()
      console.log('‚úÖ Groups loaded:', info.groups.length)
    } catch (err) {
      console.error('‚ùå Error loading groups:', err)
      info.errors.push(`Groups error: ${err.message}`)
    }

    // Check React
    info.react = {
      version: React.version,
      mode: process.env.NODE_ENV
    }

    console.log('üîç Complete debug info:', info)
    setDebugInfo(info)
  }

  const copyToClipboard = () => {
    const text = JSON.stringify(debugInfo, null, 2)
    navigator.clipboard.writeText(text).then(() => {
      alert('Debug info copied to clipboard!')
    }).catch(err => {
      console.error('Failed to copy:', err)
      alert('Failed to copy. Check console for debug info.')
    })
  }

  const exportDebugInfo = () => {
    const text = JSON.stringify(debugInfo, null, 2)
    const blob = new Blob([text], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `debug-info-${Date.now()}.json`
    a.click()
    URL.revokeObjectURL(url)
  }

  if (!isVisible) return null

  return (
    <div style={{
      position: 'fixed',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      width: '90%',
      maxWidth: '800px',
      maxHeight: '90vh',
      background: '#1F2937',
      color: '#F3F4F6',
      borderRadius: '8px',
      boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.5)',
      zIndex: 10000,
      overflow: 'hidden',
      display: 'flex',
      flexDirection: 'column'
    }}>
      {/* Header */}
      <div style={{
        padding: '16px 20px',
        background: '#111827',
        borderBottom: '1px solid #374151',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center'
      }}>
        <div>
          <h3 style={{ margin: 0, fontSize: '16px', fontWeight: '600' }}>
            üîç Debug Panel
          </h3>
          <p style={{ margin: '4px 0 0 0', fontSize: '12px', color: '#9CA3AF' }}>
            Press Ctrl+Alt+D (or Cmd+Alt+D) to close
          </p>
        </div>
        <div style={{ display: 'flex', gap: '8px' }}>
          <button
            onClick={collectDebugInfo}
            style={{
              padding: '6px 12px',
              background: '#3B82F6',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              fontSize: '12px',
              cursor: 'pointer'
            }}
          >
            Refresh
          </button>
          <button
            onClick={copyToClipboard}
            style={{
              padding: '6px 12px',
              background: '#10B981',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              fontSize: '12px',
              cursor: 'pointer'
            }}
          >
            Copy
          </button>
          <button
            onClick={exportDebugInfo}
            style={{
              padding: '6px 12px',
              background: '#F59E0B',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              fontSize: '12px',
              cursor: 'pointer'
            }}
          >
            Export
          </button>
          <button
            onClick={() => {
              if (onToggle) {
                onToggle(false)
              } else {
                setVisible(false)
              }
            }}
            style={{
              padding: '6px 12px',
              background: '#DC2626',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              fontSize: '12px',
              cursor: 'pointer'
            }}
          >
            Close
          </button>
        </div>
      </div>

      {/* Content */}
      <div style={{
        flex: 1,
        overflow: 'auto',
        padding: '20px',
        fontFamily: 'monospace',
        fontSize: '12px'
      }}>
        {/* Errors */}
        {debugInfo.errors && debugInfo.errors.length > 0 && (
          <div style={{
            padding: '12px',
            background: '#7F1D1D',
            border: '1px solid #DC2626',
            borderRadius: '4px',
            marginBottom: '16px'
          }}>
            <div style={{ fontWeight: '600', marginBottom: '8px', color: '#FCA5A5' }}>
              ‚ö†Ô∏è Errors ({debugInfo.errors.length})
            </div>
            {debugInfo.errors.map((error, i) => (
              <div key={i} style={{ marginLeft: '16px', color: '#FEE2E2' }}>‚Ä¢ {error}</div>
            ))}
          </div>
        )}

        {/* Browser Info */}
        <Section title="Browser Information">
          <KeyValue label="User Agent" value={debugInfo.browser?.userAgent} />
          <KeyValue label="Platform" value={debugInfo.browser?.platform} />
          <KeyValue label="Language" value={debugInfo.browser?.language} />
          <KeyValue label="Cookies Enabled" value={String(debugInfo.browser?.cookiesEnabled)} />
          <KeyValue label="Online" value={String(debugInfo.browser?.onLine)} />
        </Section>

        {/* React Info */}
        <Section title="React Information">
          <KeyValue label="React Version" value={debugInfo.react?.version} />
          <KeyValue label="Mode" value={debugInfo.react?.mode} />
        </Section>

        {/* localStorage Info */}
        <Section title="localStorage Status">
          <KeyValue
            label="Available"
            value={String(debugInfo.localStorage?.available)}
            highlight={!debugInfo.localStorage?.available}
          />
          <KeyValue label="Item Count" value={debugInfo.localStorage?.itemCount} />
          <KeyValue label="Total Size" value={`${debugInfo.localStorage?.totalSize} bytes`} />
          {debugInfo.localStorage?.keys && debugInfo.localStorage.keys.length > 0 && (
            <div style={{ marginTop: '8px' }}>
              <div style={{ color: '#9CA3AF', marginBottom: '4px' }}>Keys:</div>
              {debugInfo.localStorage.keys.map((key, i) => (
                <div key={i} style={{ marginLeft: '16px', color: '#D1D5DB' }}>‚Ä¢ {key}</div>
              ))}
            </div>
          )}
        </Section>

        {/* Configuration */}
        <Section title="GitLab Configuration">
          {debugInfo.config ? (
            <>
              <KeyValue label="GitLab URL" value={debugInfo.config.gitlabUrl} />
              <KeyValue label="Mode" value={debugInfo.config.mode} />
              <KeyValue label="Project ID" value={debugInfo.config.projectId || '(not set)'} />
              <KeyValue label="Group Path" value={debugInfo.config.groupPath || '(not set)'} />
              <KeyValue label="Token" value={debugInfo.config.token ? `${debugInfo.config.token.substring(0, 10)}...` : '(not set)'} />
              <KeyValue label="Filter 2025" value={String(debugInfo.config.filter2025)} />
            </>
          ) : (
            <div style={{ color: '#F59E0B' }}>No configuration found</div>
          )}
        </Section>

        {/* Projects */}
        <Section title="Projects">
          {debugInfo.projects && debugInfo.projects.length > 0 ? (
            debugInfo.projects.map((project, i) => (
              <div key={i} style={{ marginBottom: '8px', paddingLeft: '16px' }}>
                <div style={{ color: '#60A5FA' }}>‚Ä¢ {project.name}</div>
                <div style={{ marginLeft: '16px', fontSize: '11px', color: '#9CA3AF' }}>
                  ID: {project.projectId} | URL: {project.gitlabUrl}
                </div>
              </div>
            ))
          ) : (
            <div style={{ color: '#9CA3AF' }}>No projects configured</div>
          )}
        </Section>

        {/* Groups/Pods */}
        <Section title="Groups/Pods">
          {debugInfo.groups && debugInfo.groups.length > 0 ? (
            debugInfo.groups.map((group, i) => (
              <div key={i} style={{ marginBottom: '8px', paddingLeft: '16px' }}>
                <div style={{ color: '#34D399' }}>‚Ä¢ {group.name}</div>
                <div style={{ marginLeft: '16px', fontSize: '11px', color: '#9CA3AF' }}>
                  Path: {group.groupPath} | URL: {group.gitlabUrl}
                </div>
              </div>
            ))
          ) : (
            <div style={{ color: '#9CA3AF' }}>No groups/pods configured</div>
          )}
        </Section>

        {/* Raw Data */}
        <Section title="Raw Debug Data (JSON)">
          <pre style={{
            background: '#111827',
            padding: '12px',
            borderRadius: '4px',
            overflow: 'auto',
            fontSize: '11px',
            color: '#D1D5DB'
          }}>
            {JSON.stringify(debugInfo, null, 2)}
          </pre>
        </Section>
      </div>
    </div>
  )
}

function Section({ title, children }) {
  return (
    <div style={{ marginBottom: '24px' }}>
      <h4 style={{
        margin: '0 0 12px 0',
        fontSize: '14px',
        fontWeight: '600',
        color: '#60A5FA',
        borderBottom: '1px solid #374151',
        paddingBottom: '8px'
      }}>
        {title}
      </h4>
      {children}
    </div>
  )
}

function KeyValue({ label, value, highlight }) {
  return (
    <div style={{
      display: 'grid',
      gridTemplateColumns: '200px 1fr',
      gap: '12px',
      marginBottom: '8px',
      padding: '4px 0'
    }}>
      <div style={{ color: '#9CA3AF' }}>{label}:</div>
      <div style={{
        color: highlight ? '#F87171' : '#F3F4F6',
        fontWeight: highlight ? '600' : 'normal',
        wordBreak: 'break-all'
      }}>
        {value || '(empty)'}
      </div>
    </div>
  )
}

```

---

